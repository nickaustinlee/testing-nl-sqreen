'use strict';
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const Transports = require('../transports');

const ARG_CACHE = new WeakMap();

module.exports = function (payload, ecoSystemInterface) {

    const request = payload.request;
    if (request !== './lib/channel_model' && request !== './lib/callback_model') {
        return;
    }

    const module = payload.module;
    const identity = payload.identity;

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const pre = function (args, value, rule, selfObject) {

        const todo = transport.shouldPropagate(TRANSPORT.SCOPE.PRODUCER);
        const trigger = todo.trigger;
        const fields = todo.fields;

        if (fields.length === 0) {
            return; // Do nothing here
        }

        const resolved = new Transports.ProducerTransport();
        resolved.addMessageType(fields, TRANSPORT.TRANSPORT_TYPE.AMQP);
        resolved.addTA(fields, ecoSystemInterface);
        const host = selfObject.connection.stream._host;
        if (fields.indexOf('host') > -1) {
            resolved.host = host;
        }
        resolved.addIP(fields, host);
        if (fields.indexOf('topic') > -1) {
            resolved.topic = args[1];
        }
        const cleanup = transport.propagate(resolved, trigger);
        ARG_CACHE.set(args, cleanup);
    };

    const post = function (args) {

        const cleanup = ARG_CACHE.get(args);
        if (typeof cleanup === 'function') {
            cleanup();
        }
    };

    instrumentation.strategies.wrap(module.Channel.prototype, 'publish', identity, 'Channel.prototype', { method: pre }, { method: post });
};
