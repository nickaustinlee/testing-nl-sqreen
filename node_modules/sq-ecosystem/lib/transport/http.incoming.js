/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const UuidV4 = require('uuid/v4');
const OnFinished = require('on-finished');
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const HEADERS = require('../enums').HEADERS;
const Transports = require('../transports');

const isEmitter = function (emitter) {

    return !!(emitter && emitter.on && emitter.addListener && emitter.emit);
};

const cleanup = function (transport, req, res, record, budgetSum, budget, monitBudget, session, holder) {

    transport.stopIncomingTransaction(req, () => {

        req.__sqreen = undefined;
        req.__sqreen_lookable = undefined;
        req.__sqreen_res = undefined;
        req.__sqreen_url = undefined;

        if (record) {
            session.run(() => {

                session.set('req', req);
                session.set('res', res);
                holder.end.apply(res, [req]);
                transport.stopHttpTransaction(req, res, record, budgetSum, budget, monitBudget);
            });
        }
    });
};

/**
 * @param payload {{module: any, identity: any}}
 * @param ecoSystemInterface
 */
module.exports = function (payload, ecoSystemInterface) {

    const module = payload.module;
    const identity = payload.identity;

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const utils = transport.utils;
    const ipAndPath = transport.ipAndPath;
    const checkIPandPath = ipAndPath.checkIPandPath;
    const ipPathAction = ipAndPath.ACTIONS;
    const Server = module.Server;

    // we want 1 instance of this per call so we can have 1 for http and another one for https
    const holder = {
        end: function () {
        },
        request: function (ip) {

            return true;
        },
        request_second_hook: function () {

            return true;
        }
    };
    const getHook = function (server, listener) {

        instrumentation.registerHttpServerForReveal(server);

        return function (req, res) {

            if (!isEmitter(req) || !isEmitter(res)) {
                return listener.apply(this, arguments);
            }
            transport.startIncomingTransaction(req, (session, budget, monitBudget) => { // TODO: abstract in agent

                budget.startCount();
                req.__sqreen_url = req.url;
                req.__sqreen_res = res;
                res.__original_end = res.end;
                req.__sqreen_uuid = UuidV4();

                session.bindEmitter(req);
                session.bindEmitter(res);

                session.set('req', req);
                session.set('res', res);
                const ipAddress = utils.ensureProperIP(utils.getXFFOrRemoteAddress(req)) || '';
                if (checkIPandPath(ipAddress, req, res) === ipPathAction.PREVENT) {
                    return; // do not let this go through
                }

                // prevent double writing if request was sqreen_dropped
                // see rule-callback/utils.js:11
                const write = res.write;
                res.write = function () {

                    if (!this.__sqreen_finisehd) {
                        return write.apply(this, arguments);
                    }
                };

                const record = transport.getHttpTrace(req, ipAddress);

                const toPropagate = transport.shouldPropagate(TRANSPORT.SCOPE.HTTP.INCOMING);
                const trigger = toPropagate.trigger;
                const fields = toPropagate.fields;

                let memCleanup = () => {};
                if (fields.length > 0) {
                    const resolved = new Transports.ServerTransport();
                    // previous_hops is not supported yet
                    if (fields.indexOf('client_ip') > -1) {
                        resolved.client_ip = ipAddress;
                    }
                    if (fields.indexOf('transport') > -1) {
                        resolved.transport = TRANSPORT.TRANSPORT_TYPE.HTTP;
                    }
                    if (fields.indexOf('tracing_identifier') > -1) {
                        resolved.tracing_identifier = req.headers[HEADERS.X_SQREEN_TRACKING] || '';
                    }
                    memCleanup = transport.propagate(resolved, trigger);
                }

                OnFinished(res, () => {

                    memCleanup();
                    cleanup(transport, req, res, record, budget.sum, budget, monitBudget, session, holder);
                });
                res.on('finish', () => {

                    memCleanup();
                    cleanup(transport, req, res, record, budget.sum, budget, monitBudget, session, holder);
                });

                if (holder.request(ipAddress, req, res)) {
                    if (req._sqreen_ip_whitelist || holder.request_second_hook('request', req, res)) {
                        budget.stopCount();
                        return listener.apply(this, arguments);
                    }
                }
            });
        };
    };

    instrumentation.strategies.patchFunction(holder, 'end', identity, 'ServerResponse.on');
    instrumentation.strategies.patchFunction(holder, 'request', identity, 'Server.on');
    instrumentation.strategies.patchFunction(holder, 'request_second_hook', identity, 'Server.on');

    instrumentation.strategies.patchEventListeners(Server.prototype, 'request', getHook);
};
module.exports.isEmitter = isEmitter;
module.exports._cleanup = cleanup;
