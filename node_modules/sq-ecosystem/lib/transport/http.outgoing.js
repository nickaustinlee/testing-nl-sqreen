/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Semver = require('semver');
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const HEADERS = require('../enums').HEADERS;
const Url = require('url');
const Net = require('net');
const Transports = require('../transports');

// URL is available as node 10.0.0

const insertOutGoingHeader = function (args, key, value) {

    //$lab:coverage:off$
    if (Semver.satisfies(process.version, '< 10.9.0')) { // older is too weird for now
        return;
    }
    //$lab:coverage:on$

    let options;
    const first = args[0];
    if (typeof first === 'object' && !(first instanceof Url.URL)) {
        // easy case
        options = args[0];
    }
    else if (typeof args[1] === 'function') {
        options = {};
        args[2] = args[1];
        args[1] = options;
        args.length++; // not an array
    }
    else {
        options = args[1];
        if (typeof options !== 'object' || options === null) {
            options = {};
            args[1] = options;
        }
    }
    options.headers = options.headers || {};
    options.headers[key] = value;
};

/**
 *
 * @param args
 * @return {{ip?: string, host: string}}
 */
const getHostAndIp = function (args) {

    let ip;
    let host = '';
    if (typeof args[0] === 'object') {
        // this is either an option or a URL object. They both have host
        host = args[0].host || args[0].hostname;
        ip = args[0].ip;
        if (host && host.indexOf(':') > -1) {
            host = host.split(':')[0];
        }
    }
    if (typeof args[0] === 'string') {
        const parsed = Url.parse(args[0]);
        //$lab:coverage:off$
        host = parsed.hostname || parsed.host;
        //$lab:coverage:on$
        if (parsed.port !== null) {
            host = host.replace(`:${parsed.port}`, '');
        }
    }
    if (!ip && Net.isIP(host)) {
        ip = host;
    }
    return { host, ip };
};

const httpOutgoingHook = function (args, flavor, ecoSystemInterface) {

    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const todo = transport.shouldPropagate(TRANSPORT.SCOPE.HTTP.OUTGOING);
    const trigger = todo.trigger;
    const fields = todo.fields;

    if (fields.length === 0) {
        return; // Do nothing here
    }
    const resolved = new Transports.ClientTransport();

    // the follwing fields only will be supported
    // transport, ip, host,
    //             tracing_identifier
    if (fields.indexOf('transport') > -1) {
        resolved.transport = TRANSPORT.TRANSPORT_TYPE.HTTP;
    }

    const tracingIdentifier = ecoSystemInterface
        .getInterface(INTERFACES.TRACING)
        .getTracingIdentifier();

    if (fields.indexOf('tracing_identifier') > -1) {
        resolved.tracing_identifier = tracingIdentifier;
    }

    const needHost = fields.indexOf('host') > -1;
    const needIP = fields.indexOf('ip') > -1;
    if (needHost === true || needIP === true) {
        const hostAndIp = getHostAndIp(args);
        if (needHost === true) {
            resolved.host = hostAndIp.host;
        }
        if (needIP === true) {
            resolved.ip = hostAndIp.ip;
        }
    }

    const cleanup = transport.propagate(resolved, trigger);

    // We need to add the tracing header too
    insertOutGoingHeader(args, HEADERS.X_SQREEN_TRACKING, tracingIdentifier);

    const lasArg = args[args.length - 1];
    if (typeof lasArg === 'function') {
        // we need to replace the last arg to place a spy on the callback resolution!
        const newCallback = function () {

            cleanup();
            return lasArg.apply(this, arguments);
        };
        args[args.length - 1] = newCallback;
    }
};

const wrapOutgoing = function (module, flavor, ecoSystemInterface) {

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const toWrap = ['request'];
    const nodeVersion = Semver.coerce(process.version);
    // after Node.js 8, get does not call request anymore
    // $lab:coverage:off$
    if (Semver.satisfies(nodeVersion, '>=8.0.0')) {
        toWrap.push('get');
    }
    // $lab:coverage:on$
    // FIXME: migrate to wrap
    instrumentation.strategies.massWrap(module, toWrap, (self, args) => {

        httpOutgoingHook(args, flavor, ecoSystemInterface);
    });
};

/**
 * @param payload {{module: any, identity: any}}
 * @param ecoSystemInterface
 * @param {string} flavor
 */
module.exports = function (payload, ecoSystemInterface, flavor) {

    wrapOutgoing(payload.module, flavor, ecoSystemInterface);
};

module.exports._httpOutgoingHook = httpOutgoingHook;
module.exports._getHostAndIp = getHostAndIp;
module.exports.insertOutGoingHeader = insertOutGoingHeader;
