'use strict';
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const NS_NAME = require('../enums').NS_NAME;

const Transports = require('../transports');

// FIXME: with pseudo-closure: see sqlite

const kFIELDS = 'FIELDS';
const kRESOLVED = 'RESOLVED';
const kFINISH = 'FINISH';
const kCLEANUP = 'CLEANUP';
const kDone = 'DONE';

const kafkaSendHook = function (selfA, args, ecoSystemInterface, kafkaProducerStore) {

    // const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const todo = transport.shouldPropagate(TRANSPORT.SCOPE.PRODUCER);
    const trigger = todo.trigger;
    const fields = todo.fields;
    //$lab:coverage:off$
    if (fields.length === 0) {
        return; // Do nothing here
        //$lab:coverage:on$
    }
    const resolved = new Transports.ProducerTransport();
    // for now, we will only consider the first element. TODO: understand multiple message flow
    resolved.addMessageType(fields, TRANSPORT.TRANSPORT_TYPE.KAFKA);
    if (fields.indexOf('topic') > -1) {
        resolved.topic = args[0][0].topic;
    }

    resolved.addTA(fields, ecoSystemInterface);

    const finish = function () {

        const cleanup = transport.propagate(resolved, trigger);
        kafkaProducerStore.set(kCLEANUP, cleanup);
    };

    if (fields.indexOf('host') > -1 || fields.indexOf('ip') > -1) {
        // we can't send things now, we will need to wait for the other method to be called
        kafkaProducerStore.set(kFIELDS, fields);
        kafkaProducerStore.set(kRESOLVED, resolved);
        kafkaProducerStore.set(kFINISH, finish);
        kafkaProducerStore.set(kDone, false);
        return;
    }
    finish();
};

module.exports = function (payload, ecoSystemInterface) {

    const request = payload.request;
    if (request !== 'kafka-node') {
        return;
    }

    const module = payload.module;
    const identity = payload.identity;

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const tracing = ecoSystemInterface.getInterface(INTERFACES.TRACING);
    const kafkaProducerStore = tracing.getAsyncStorage(NS_NAME);
    const pre = {
        method: function (args, v, _, selfObject) {

            const context = Object.create(null);
            kafkaProducerStore.enter(context);
            return kafkaSendHook(selfObject, args, ecoSystemInterface, kafkaProducerStore);
        }
    };
    const post = {
        method: function () {

            try {
                kafkaProducerStore.exit(kafkaProducerStore.active);
            }
            catch (_) {} // active might be empty
        }
    }; // TODO? mark as nobudget?

    const asyncPost = {
        method: function () {

            //$lab:coverage:off$
            if (kafkaProducerStore) {
                const cleanup = kafkaProducerStore.get(kCLEANUP);
                if (typeof cleanup === 'function') {
                    //$lab:coverage:on$
                    cleanup();
                }
                try {
                    kafkaProducerStore.exit(kafkaProducerStore.active);
                }
                catch (_) {} // active might be empty
            }
        }
    };

    const postBroker = {
        method: function (args, value) {

            // try catch?
            //$lab:coverage:off$
            if (kafkaProducerStore) {
                if (kafkaProducerStore.get(kDone) === true) {
                    return;
                }
                //$lab:coverage:on$
                kafkaProducerStore.set(kDone, true);

                const finish = kafkaProducerStore.get(kFINISH);
                const resolved = kafkaProducerStore.get(kRESOLVED);
                const fields = kafkaProducerStore.get(kFIELDS);
                const host = value.socket.host;

                if (!fields) {
                    return;
                }

                if (fields.indexOf('host') > -1) {
                    resolved.host = host;
                }
                resolved.addIP(fields, host);
                finish();
            }

        }
    };

    instrumentation.strategies.wrap(module.Producer.prototype, 'send', identity, 'Producer.prototype', pre, post, asyncPost);
    instrumentation.strategies.wrap(module.KafkaClient.prototype, 'brokerForLeader', identity, 'Producer.prototype', undefined, postBroker);
};
