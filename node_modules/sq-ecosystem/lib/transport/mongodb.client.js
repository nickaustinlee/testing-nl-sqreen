'use strict';
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const Transports = require('../transports');

const ARGS_CLEANUP = new WeakMap();

const getHost = function (selfObject) {

    return selfObject.s.topology.s.host;
};

module.exports = function (payload, ecoSystemInterface) {

    const identity = payload.identity;
    const request = payload.request;

    if (request !== './collection') {
        return;
    }

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);
    const module = payload.module;

    const pre = {
        method: function (args, value, rule, selfObject) {

            const todo = transport.shouldPropagate(TRANSPORT.SCOPE.CLIENT);
            const trigger = todo.trigger;
            const fields = todo.fields;
            if (fields.length === 0) {
                return; // Do nothing here
            }
            const resolved = new Transports.ClientTransport();
            resolved.addTransport(fields, TRANSPORT.TRANSPORT_TYPE.MONGO);
            resolved.addTA(fields, ecoSystemInterface);
            if (fields.indexOf('host') > -1) {
                resolved.host = getHost(selfObject);
            }
            resolved.addIP(fields, getHost(selfObject));
            const cleanup = transport.propagate(resolved, trigger);
            ARGS_CLEANUP.set(args, cleanup);
        }
    };

    const asyncPost = {
        method: function (args) {

            const cleanup = ARGS_CLEANUP.get(args);
            if (typeof cleanup === 'function') {
                cleanup();
            }
        }
    };

    const methods = [
        'insertOne',
        'insertMany',
        'bulkWrite',
        'insert',
        'updateOne',
        'replaceOne',
        'updateMany',
        'update',
        'deleteOne',
        'removeOne',
        'deleteMany',
        'removeMany',
        'remove',
        // 'findOne', -> covered by find
        'findOneAndDelete',
        'findOneAndReplace',
        'findOneAndUpdate',
        'findAndModify',
        'findAndRemove'
    ];
    methods.forEach((met) => {

        instrumentation.strategies.wrap(module.prototype, met, identity, 'prototype', pre, null, asyncPost);
    });
    instrumentation.strategies.wrap(module.prototype, 'find', identity, 'prototype', pre, asyncPost);

};
