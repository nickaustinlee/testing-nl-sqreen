'use strict';
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const Transports = require('../transports');

const ARGS_CLEANUP = new WeakMap();

const PATHS = {
    mysql: {
        connection: './lib/Connection'
    },
    mysql2: {
        connection: './lib/connection.js'
    }
};

module.exports = function (payload, ecoSystemInterface) {

    const identity = payload.identity;
    const request = payload.request;
    const getHost = (selfO) => selfO.config.host;

    const path = PATHS[identity.name];

    if (request !== path.connection) {
        return;
    }

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);
    const module = payload.module;

    const pre = {
        method: function (args, value, rule, selfObject) {

            const todo = transport.shouldPropagate(TRANSPORT.SCOPE.CLIENT);
            const trigger = todo.trigger;
            const fields = todo.fields;
            if (fields.length === 0) {
                return; // Do nothing here
            }
            const resolved = new Transports.ClientTransport();
            resolved.addTransport(fields, TRANSPORT.TRANSPORT_TYPE.MYSQL);
            resolved.addTA(fields, ecoSystemInterface);
            if (fields.indexOf('host') > -1) {
                resolved.host = getHost(selfObject);
            }
            resolved.addIP(fields, getHost(selfObject));
            const cleanup = transport.propagate(resolved, trigger);
            ARGS_CLEANUP.set(args, cleanup);
        }
    };

    const asyncPost = {
        method: function (args) {

            const cleanup = ARGS_CLEANUP.get(args);
            if (typeof cleanup === 'function') {
                cleanup();
            }
        }
    };

    instrumentation.strategies.wrap(module.prototype, 'query', identity, 'prototype', pre, null, asyncPost);
};
