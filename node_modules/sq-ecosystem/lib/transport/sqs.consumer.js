'use strict';
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const Transports = require('../transports');
const Url = require('url');

const Shimmer = require('shimmer');
// FIXME: topic is missing
module.exports = function (payload, ecoSystemInterface) {

    const request = payload.request;
    if (request !== 'aws-sdk') {
        return;
    }

    const module = payload.module;

    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const patch = function () {

        Shimmer.wrap(module.SQS.prototype, 'receiveMessage', (original) => {

            return function (params, originalCB) { // FIXME: there is a cb-less path to discuss and handle

                let host = '';
                let topic = '';
                // might be worth checking AWS X-ray at this point
                if (typeof originalCB !== 'function') {
                    return original.apply(this, arguments);
                }
                try {
                    const parsed = Url.parse(params.QueueUrl);
                    host = parsed.hostname;
                    topic = parsed.path.split('/').pop();
                }
                catch (_) {}
                // cb is a function
                const newCb = function (err, data) {

                    if (err) { // should we do something? Error-based injections :scream:
                        return originalCB.apply(this, arguments);
                    }

                    const self = this;
                    const args = arguments;
                    transport.startIncomingTransaction(data, (session, budget) => { // TODO: ensure there is no strong link to budget!! we will never close it

                        try {
                            budget.startCount();
                            session.set('incoming_sqs_data', data);

                            const todo = transport.shouldPropagate(TRANSPORT.SCOPE.HTTP.OUTGOING); // TODO: nothing comes from the message actually
                            const trigger = todo.trigger;
                            const fields = todo.fields;

                            if (fields.length !== 0) {
                                const resolved = new Transports.ConsumerTransport();
                                resolved.addMessageType(fields, TRANSPORT.TRANSPORT_TYPE.SQS);
                                if (fields.indexOf('host') > -1) {
                                    resolved.host = host;
                                }
                                resolved.addTA(fields, ecoSystemInterface);
                                resolved.addIP(fields, host);
                                if (fields.indexOf('topic') > -1) {
                                    resolved.topic = topic;
                                }
                                transport.propagate(resolved, trigger); // Cleanup will never be called in that case :thinking:
                            }

                            budget.stopCount();
                        }
                        catch (e) {
                            // TODO: report?
                        }
                        return originalCB.apply(self, args);
                    });
                };
                return original.apply(this, [params, newCb]);
            };
        });
    };

    Object.defineProperty(module.SQS.prototype, 'receiveMessage', { // missing sendMessageBatch?
        configurable: true,
        set(v) {

            Object.defineProperty(module.SQS.prototype, 'receiveMessage', { value: v, configurable: true, enumerable: true, writable: true });
            patch();
        }
    });


};
