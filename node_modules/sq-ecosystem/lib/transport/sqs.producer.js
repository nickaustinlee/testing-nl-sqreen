'use strict';
/**
 * This also contains Kinesis. TODO: fix this
 */
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const Transports = require('../transports');
const Url = require('url');

const ARG_CACHE = new WeakMap();

module.exports = function (payload, ecoSystemInterface) {

    const request = payload.request;
    if (request !== 'aws-sdk') {
        return;
    }

    const module = payload.module;
    const identity = payload.identity;

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    const pre = function (args) {

        const todo = transport.shouldPropagate(TRANSPORT.SCOPE.PRODUCER);
        const trigger = todo.trigger;
        const fields = todo.fields;

        if (fields.length === 0) {
            return; // Do nothing here
        }

        const resolved = new Transports.ProducerTransport();
        resolved.addMessageType(fields, TRANSPORT.TRANSPORT_TYPE.SQS);
        resolved.addTA(fields, ecoSystemInterface);
        const parsed = Url.parse(args[0].QueueUrl);
        const host = parsed.hostname;
        if (fields.indexOf('topic') > -1) {
            resolved.topic = parsed.path.split('/').pop();
        }
        if (fields.indexOf('host') > -1) {
            resolved.host = host;
        }
        resolved.addIP(fields, host);
        const cleanup = transport.propagate(resolved, trigger);
        ARG_CACHE.set(args, cleanup);
    };

    const asyncPost = function (args) {

        const cleanup = ARG_CACHE.get(args);
        if (typeof cleanup === 'function') {
            cleanup();
        }
    };

    const preK = function (args, a, b, selfObject) {

        const todo = transport.shouldPropagate(TRANSPORT.SCOPE.PRODUCER);
        const trigger = todo.trigger;
        const fields = todo.fields;

        if (fields.length === 0) {
            return; // Do nothing here
        }

        const resolved = new Transports.ProducerTransport();
        resolved.addMessageType(fields, TRANSPORT.TRANSPORT_TYPE.KINESIS);
        resolved.addTA(fields, ecoSystemInterface);
        const host = selfObject.endpoint.hostname;
        if (fields.indexOf('host') > -1) {
            resolved.host = host;
        }
        resolved.addIP(fields, host);
        if (fields.indexOf('topic') > -1) {
            resolved.topic = args[0].PartitionKey;
        }
        const cleanup = transport.propagate(resolved, trigger);
        ARG_CACHE.set(args, cleanup);
    };

    const patch = function () {

        instrumentation.strategies.wrap(module.SQS.prototype, 'sendMessage', identity, 'SQS.prototype', { method: pre }, undefined, { method: asyncPost });
    };

    if (module.SQS) {
        Object.defineProperty(module.SQS.prototype, 'sendMessage', { // missing sendMessageBatch?
            configurable: true,
            set(v) {

                Object.defineProperty(module.SQS.prototype, 'sendMessage', { value: v, configurable: true, enumerable: true, writable: true });
                patch();
            }
        });
    }

    const patchKinesis = function () {

        instrumentation.strategies.wrap(module.Kinesis.prototype, 'putRecord', identity, 'Kinesis.prototype', { method: preK }, undefined, { method: asyncPost });
    };

    if (module.Kinesis) {
        Object.defineProperty(module.Kinesis.prototype, 'putRecord', { // missing sendMessageBatch?
            configurable: true,
            set(v) {

                Object.defineProperty(module.Kinesis.prototype, 'putRecord', { value: v, configurable: true, enumerable: true, writable: true });
                patchKinesis();
            }
        });
    }



};
