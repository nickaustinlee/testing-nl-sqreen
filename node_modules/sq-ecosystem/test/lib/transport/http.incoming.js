/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const afterEach = lab.afterEach;
const it = lab.it;
const expect = Code.expect;

const Http = require('http');

const HttpHook = require('../../../lib/transport/http.incoming');
const INTERFACES = require('../../../lib/enums').INTERFACES;
const HEADERS = require('../../../lib/enums').HEADERS;
const TestUtils = require('../../test_utils/index');

describe('Transport', () => {

    describe('http', () => {

        afterEach((done) => {

            delete Http.Server.prototype.addListener;
            delete Http.Server.prototype.on;
            if (Http.get.__unwrap) {
                Http.get.__unwrap();
            }
            if (Http.request.__unwrap) {
                Http.request.__unwrap();
            }
            done();
        });

        describe('isEmitter', () => {

            it('should cover isEmitter', { plan: 5 }, (done) => {

                expect(HttpHook.isEmitter()).to.be.false();
                expect(HttpHook.isEmitter({})).to.be.false();
                expect(HttpHook.isEmitter({ on: 1 })).to.be.false();
                expect(HttpHook.isEmitter({ on: 1, addListener: 1 })).to.be.false();
                expect(HttpHook.isEmitter({ on: 1, addListener: 1, emit: false })).to.be.false();
                done();

            });
        });

        describe('_cleanup', () => {

            it('should cover code in cleanup when no record is present', { plan: 0 }, (done) => {

                const iFace = TestUtils.getEcosystemMock();
                iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (_, cb) {

                    return cb();
                };
                HttpHook._cleanup(iFace.getInterface(INTERFACES.TRANSPORT), {});
                done();
            });
        });

        it('should hook an http server', { plan: 8 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const toPatch = new Set(['end', 'request', 'request_second_hook']);
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                expect(toPatch.has(method)).to.be.true();
                expect(hold[method]).to.exist();
                toPatch.delete(method);
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event) {

                expect(holder).to.equal(Http.Server.prototype);
                expect(event).to.equal('request');
            };
            HttpHook({ module: Http, identity: {} }, iFace);
            done();
        });

        it('should intercept the lifecycle of an HTTP request', { plan: 18 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['client_ip'],
                    trigger: {}
                };
            };

            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(trigger).to.equal({});
                expect(resolved).to.equal({ client_ip: '127.0.0.1' });
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.write('ok\n');
                    res.__sqreen_finisehd = true;
                    res.write('should not go through');
                    res.end();
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it', { plan: 19 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport'],
                    trigger: {}
                };
            };
            let cup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved).to.equal({ transport: 'http' });
                return function () {

                    cup = true;
                };
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        expect(cup).to.be.true();
                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it', { plan: 20 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };

            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'foo';
            };

            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport', 'tracing_identifier'],
                    trigger: {}
                };
            };
            let cup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved.transport).to.equal('http');
                expect(resolved.tracing_identifier).to.equal('track_id');
                return function () {

                    cup = true;
                };
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: { name: 'http' } }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port, headers: { [HEADERS.X_SQREEN_TRACKING]: 'track_id' } }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        expect(cup).to.be.true();
                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it without ti', { plan: 20 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };

            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'foo';
            };

            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport', 'tracing_identifier'],
                    trigger: {}
                };
            };
            let cup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved.transport).to.equal('http');
                expect(resolved.tracing_identifier).to.equal('');
                return function () {

                    cup = true;
                };
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: { name: 'http' } }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        expect(cup).to.be.true();
                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of a whitelisted HTTP request', { plan: 16 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                req._sqreen_ip_whitelist = true;
                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request and prevent it to go through', { plan: 9 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };


            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (_, cb) {

                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('');
                return '';
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('');
                res.end('blocked\n');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.PREVENT;
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should not track this since req is not en event emitter', { plan: 1 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function () {};
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (_, __, factory) {

                const listener = factory(this, (req) => {

                    expect(req.__sqreen_uuid).to.not.exist();
                    done();
                });
                listener({});
            };
            HttpHook({ module: Http, identity: {} }, iFace);
        });
    });
});
