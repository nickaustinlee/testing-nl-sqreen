/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const afterEach = lab.afterEach;
const it = lab.it;
const expect = Code.expect;

const Semver = require('semver');
const Http = require('http');
const Shimmer = require('shimmer');
const HttpOutgoingTransport = require('../../../lib/transport/http.outgoing');
const INTERFACES = require('../../../lib/enums').INTERFACES;
const Url = require('url');

describe('http.outgoing', () => {

    describe('Real cases', () => {

        afterEach((d) => {

            try {
                Shimmer.unwrap(Http, 'request');
            }
            catch (_) {}
            try {
                Shimmer.unwrap(Http, 'get');
            }
            catch (_) {}
            d();
        });

        it('should instantiate the right hooks at the right spots', { plan: 3 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.INSTRUMENTATION].strategies.massWrap = function (mods, methods, pre) {

                Shimmer.massWrap(mods, methods, (orig) => {

                    return function () {

                        pre(this, arguments);
                        return orig.apply(this, arguments);
                    };
                });
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['host', 'ip'],
                    trigger: { calls: 1 }
                };
            };

            let cleanup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({ host: 'localhost', ip: undefined });
                expect(trigger).to.equal({ calls: 1 });

                return function () {

                    cleanup = true;
                };
            };

            HttpOutgoingTransport({ module: Http, identity: {} }, iFace, 'http');

            const server = Http.createServer((req, res) => {

                res.end('ok\n');
            }).listen();

            Http.get(`http://localhost:${server.address().port}`, () => {

                expect(cleanup).to.be.true();
                server.close();
                done();
            });
        });

        it('should instantiate the right hooks at the right spots', { plan: 3 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.INSTRUMENTATION].strategies.massWrap = function (mods, methods, pre) {

                Shimmer.massWrap(mods, methods, (orig) => {

                    return function () {

                        pre(this, arguments);
                        return orig.apply(this, arguments);
                    };
                });
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['ip', 'transport', 'tracing_identifier'],
                    trigger: { calls: 1 }
                };
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'id';
            };

            let cleanup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({ ip: undefined, transport: 'http', tracing_identifier: 'id' });
                expect(trigger).to.equal({ calls: 1 });

                return function () {

                    cleanup = true;
                };
            };

            HttpOutgoingTransport({ module: Http, identity: {} }, iFace, 'http');

            const server = Http.createServer((req, res) => {

                res.end('ok\n');
            }).listen();

            Http.get(`http://localhost:${server.address().port}`, (res) => {

                expect(cleanup).to.be.true();
                server.close();
                done();
            });
        });

        it('should instantiate the right hooks at the right spots', { plan: 3 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.INSTRUMENTATION].strategies.massWrap = function (mods, methods, pre) {

                Shimmer.massWrap(mods, methods, (orig) => {

                    return function () {

                        pre(this, arguments);
                        return orig.apply(this, arguments);
                    };
                });
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['ip', 'transport', 'tracing_identifier'],
                    trigger: { calls: 1 }
                };
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'id';
            };

            let cleanup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({ ip: '127.0.0.1', transport: 'http', tracing_identifier: 'id' });
                expect(trigger).to.equal({ calls: 1 });

                return function () {

                    cleanup = true;
                };
            };

            HttpOutgoingTransport({ module: Http, identity: {} }, iFace, 'http');

            const server = Http.createServer((req, res) => {

                res.end('ok\n');
            }).listen();

            Http.get({ host: '127.0.0.1', port: server.address().port }, (res) => {

                expect(cleanup).to.be.true();
                server.close();
                done();
            });
        });

        it('should instantiate the right hooks at the right spots', { plan: 3 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.INSTRUMENTATION].strategies.massWrap = function (mods, methods, pre) {

                Shimmer.massWrap(mods, methods, (orig) => {

                    return function () {

                        pre(this, arguments);
                        return orig.apply(this, arguments);
                    };
                });
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['ip', 'transport', 'tracing_identifier'],
                    trigger: { calls: 1 }
                };
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'id';
            };

            let cleanup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({ ip: '127.0.0.1', transport: 'http', tracing_identifier: 'id' });
                expect(trigger).to.equal({ calls: 1 });

                return function () {

                    cleanup = true;
                };
            };

            HttpOutgoingTransport({ module: Http, identity: {} }, iFace, 'http');

            const server = Http.createServer((req, res) => {

                res.end('ok\n');
            }).listen();

            Http.get({ ip: '127.0.0.1', port: server.address().port }, (res) => {

                expect(cleanup).to.be.true();
                server.close();
                done();
            });
        });

        it('should instantiate the right hooks at the right spots', { plan: 3 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.INSTRUMENTATION].strategies.massWrap = function (mods, methods, pre) {

                Shimmer.massWrap(mods, methods, (orig) => {

                    return function () {

                        pre(this, arguments);
                        return orig.apply(this, arguments);
                    };
                });
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['transport', 'tracing_identifier', 'host'],
                    trigger: { calls: 1 }
                };
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'id';
            };

            let cleanup = false;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({ transport: 'http', tracing_identifier: 'id', host: 'localhost' });
                expect(trigger).to.equal({ calls: 1 });

                return function () {

                    cleanup = true;
                };
            };

            HttpOutgoingTransport({ module: Http, identity: {} }, iFace, 'http');

            const server = Http.createServer((req, res) => {

                res.end('ok\n');
            }).listen();

            Http.get('http://localhost:' + server.address().port, (res) => {

                expect(cleanup).to.be.true();
                server.close();
                done();
            });
        });
    });

    describe('httpOutgoingHook', () => {

        it('should cover last cases of httpOutgoingHook', { plan: 2 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return '1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: ['transport', 'tracing_identifier', 'host', 'ip'],
                    trigger: { calls: 1 }
                };
            };
            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'id';
            };


            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(resolved).to.equal({
                    transport: 'http',
                    tracing_identifier: 'id',
                    host: 'hello.word',
                    ip: undefined
                });
                expect(trigger).to.equal({ calls: 1 });
                done();
            };
            HttpOutgoingTransport._httpOutgoingHook(['https://hello.word'], 'https', iFace);
        });

        it('should cover last cases of httpOutgoingHook', { plan: 0 }, (done) => {

            const iFace = require('../../test_utils/').getEcosystemMock();

            iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

                return {
                    fields: [],
                    trigger: { calls: 1 }
                };
            };
            HttpOutgoingTransport._httpOutgoingHook(['https://hello.word'], 'https', iFace);
            done();
        });
    });

    describe('getHostAndIp', () => {

        it('should cover edge case', { plan: 1 }, (done) => {

            expect(HttpOutgoingTransport._getHostAndIp([{ host: 'hello:545' }]).host).to.equal('hello');
            done();
        });
    });

    if (Semver.satisfies(process.version, '>= 10.9.0')) {
        describe('insertOutGoingHeader', () => {

            const getArg = function () {

                return arguments;
            };

            const testThis = function (i, getArgs) {

                it('should inject a header ' + i, { plan: 2 }, (done) => {

                    const s = Http.createServer((req, res) => {

                        expect(req.headers['x-test']).to.equal('ok');
                        res.setHeader('result', 'ok');
                        res.end('ok\n');
                    });

                    s.listen(() => {

                        const args = getArgs(s);
                        args.push((res) => {

                            expect(res.headers.result).to.equal('ok');
                            s.close(() => {

                                done();
                            });
                        });
                        const argArg = getArg.apply(null, args);
                        HttpOutgoingTransport.insertOutGoingHeader(argArg, 'x-test', 'ok');
                        Http.get.apply(Http, argArg);
                    });
                });
            };

            const set = [
                (s) => [{ host: 'localhost', port: s.address().port }],
                (s) => [Url.parse('http://localhost:' + s.address().port)],
                (s) => [new URL('http://localhost:' + s.address().port)],
                (s) => [new URL('http://localhost:' + s.address().port), { headers: { foo: 'bar' } }],
                (s) => ['http://localhost:' + s.address().port],
                (s) => ['http://localhost:' + s.address().port, {}],
                (s) => ['http://localhost:' + s.address().port, { headers: { foo: 'bar' } }]
            ];
            for (let i = 0; i < set.length; ++i) {
                testThis(i, set[i]);
            }
        });
    }
});
