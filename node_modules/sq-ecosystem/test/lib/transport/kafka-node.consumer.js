/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const KafkaConsumer = require('../../../lib/transport/kafka-node.consumer');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('kafka.consumer', () => {

    it('should test kafka on message', { plan: 5 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        const b = {
            startCount() {

                expect(1).to.equal(1);
            },
            stopCount() {

                expect(1).to.equal(1);
            }
        };
        const s = new Map();

        iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

            expect(event).to.equal('message');
            const addListener = holder.addListener;
            holder.addListener = function (evt, listener) {

                if (evt === event) {
                    arguments[1] = hookFactory(this, listener);
                }
                return addListener.apply(this, arguments);
            };
            holder.on = holder.addListener;
            // TODO
        };

        iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (o, cb) {

            return cb(s, b);
        };

        iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

            return 'ti';
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['host', 'ip', 'tracing_identifier', 'topic'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

            expect(trigger).to.equal({});
            expect(resolved).to.equal({
                host: '127.0.0.1',
                ip: '127.0.0.1',
                tracing_identifier: 'ti',
                topic: 'top'
            });
            return function () {

                throw new Error('should not be called');
            };
        };

        const module = {
            Consumer: class extends require('events') {

                constructor(kafkaHost) {

                    super();

                    this.client = {
                        options: {
                            kafkaHost
                        }
                    };
                }


            }
        };

        KafkaConsumer({ module, identity: {}, request: 'kafka-node' }, iFace);
        KafkaConsumer({ module, identity: {}, request: 'aws-sdk3' }, iFace);
        const prod = new module.Consumer('127.0.0.1:9092');

        prod.on('message', () => {

            done();
        });
        prod.emit('message', { topic: 'top' });
    });

    it('should test kafka on message', { plan: 5 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        const b = {
            startCount() {

                expect(1).to.equal(1);
            },
            stopCount() {

                expect(1).to.equal(1);
            }
        };
        const s = new Map();

        iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

            expect(event).to.equal('message');
            const addListener = holder.addListener;
            holder.addListener = function (evt, listener) {

                if (evt === event) {
                    arguments[1] = hookFactory(this, listener);
                }
                return addListener.apply(this, arguments);
            };
            holder.on = holder.addListener;
            // TODO
        };

        iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (o, cb) {

            return cb(s, b);
        };

        iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

            return 'ti';
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['ip', 'tracing_identifier'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

            expect(trigger).to.equal({});
            expect(resolved).to.equal({
                ip: '127.0.0.1',
                tracing_identifier: 'ti'
            });
            return function () {

                throw new Error('should not be called');
            };
        };

        const module = {
            Consumer: class extends require('events') {

                constructor(kafkaHost) {

                    super();

                    this.client = {
                        options: {
                            kafkaHost
                        }
                    };
                }


            }
        };

        KafkaConsumer({ module, identity: {}, request: 'kafka-node' }, iFace);
        KafkaConsumer({ module, identity: {}, request: 'aws-sdk3' }, iFace);
        const prod = new module.Consumer('127.0.0.1');

        prod.on('message', () => {

            done();
        });
        prod.emit('message', {});
    });

    it('should test kafka on message', { plan: 3 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        const b = {
            startCount() {

                expect(1).to.equal(1);
            },
            stopCount() {

                expect(1).to.equal(1);
            }
        };
        const s = new Map();

        iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

            expect(event).to.equal('message');
            const addListener = holder.addListener;
            holder.addListener = function (evt, listener) {

                if (evt === event) {
                    arguments[1] = hookFactory(this, listener);
                }
                return addListener.apply(this, arguments);
            };
            holder.on = holder.addListener;
            // TODO
        };

        iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (o, cb) {

            return cb(s, b);
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: [],
                trigger: {}
            };
        };

        const module = {
            Consumer: class extends require('events') {

                constructor(kafkaHost) {

                    super();

                    this.client = {
                        options: {
                            kafkaHost
                        }
                    };
                }


            }
        };

        KafkaConsumer({ module, identity: {}, request: 'kafka-node' }, iFace);
        KafkaConsumer({ module, identity: {}, request: 'aws-sdk3' }, iFace);
        const prod = new module.Consumer('127.0.0.1');

        prod.on('message', () => {

            done();
        });
        prod.emit('message', {});
    });

});
