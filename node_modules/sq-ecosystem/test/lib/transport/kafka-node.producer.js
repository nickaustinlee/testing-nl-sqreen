/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');

const KafkaNodeProducerTransport = require('../../../lib/transport/kafka-node.producer');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('kafka-node.producer', () => {

    it('should test kafka-node Producer.prototype.send', { plan: 2 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost) {

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre && pre.method(arguments);

                    const last = arguments[arguments.length - 1];
                    arguments[arguments.length - 1] = function () {

                        asyncPost && asyncPost.method(); // TODO: check args somedays;
                        return last.apply(this, arguments);
                    };
                    const res = original.apply(this, arguments);
                    post && post.method(arguments, res);
                    return res;
                };
            });
        };
        iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

            return 'ti';
        };
        iFace[INTERFACES.TRACING].getAsyncStorage = function () {

            const res = new Map();
            res.enter = () => {};
            res.exit = () => {};
            return res;
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['host', 'ip', 'tracing_identifier', 'topic'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

            expect(trigger).to.equal({});
            expect(resolved).to.equal({
                host: '127.0.0.1',
                ip: '127.0.0.1',
                tracing_identifier: 'ti',
                topic: 'test'
            });
            return function () {

                done();
            };
        };

        const module = {
            Producer: class {

                send(payloads, cb) {

                    const cli = new module.KafkaClient();
                    cli.brokerForLeader();
                    cb();
                }
            },
            KafkaClient: class {

                brokerForLeader() {

                    return {
                        socket: {
                            host: '127.0.0.1'
                        }
                    };
                }
            }
        };

        KafkaNodeProducerTransport({ module, identity: {}, request: 'kafka-node' }, iFace);
        const prod = new module.Producer();
        prod.send([{ topic: 'test' }], () => {});
    });

    it('should test kafka-node Producer.prototype.send', { plan: 2 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost) {

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre && pre.method(arguments);

                    const last = arguments[arguments.length - 1];
                    arguments[arguments.length - 1] = function () {

                        asyncPost && asyncPost.method(); // TODO: check args somedays;
                        return last.apply(this, arguments);
                    };
                    const res = original.apply(this, arguments);
                    post && post.method(arguments, res);
                    return res;
                };
            });
        };
        iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

            return 'ti';
        };
        iFace[INTERFACES.TRACING].getAsyncStorage = function () {

            const res = new Map();
            res.enter = () => {};
            res.exit = () => {};
            return res;
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['ip', 'tracing_identifier', 'topic'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

            expect(trigger).to.equal({});
            expect(resolved).to.equal({
                ip: '127.0.0.1',
                tracing_identifier: 'ti',
                topic: 'test'
            });
            return function () {

                done();
            };
        };

        const module = {
            Producer: class {

                send(payloads, cb) {

                    const cli = new module.KafkaClient();
                    cli.brokerForLeader();
                    cb();
                }
            },
            KafkaClient: class {

                brokerForLeader() {

                    return {
                        socket: {
                            host: '127.0.0.1'
                        }
                    };
                }
            }
        };

        KafkaNodeProducerTransport({ module, identity: {}, request: 'kafka-node' }, iFace);
        const prod = new module.Producer();
        prod.send([{ topic: 'test' }], () => {});
    });

    it('should test kafka-node Producer.prototype.send', { plan: 2 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost) {

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre && pre.method(arguments);

                    const last = arguments[arguments.length - 1];
                    arguments[arguments.length - 1] = function () {

                        asyncPost && asyncPost.method(); // TODO: check args somedays;
                        return last.apply(this, arguments);
                    };
                    const res = original.apply(this, arguments);
                    post && post.method(arguments, res);
                    return res;
                };
            });
        };
        iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

            return 'ti';
        };
        iFace[INTERFACES.TRACING].getAsyncStorage = function () {

            const res = new Map();
            res.enter = () => {};
            res.exit = () => {};
            return res;
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['message_type'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

            expect(trigger).to.equal({});
            expect(resolved).to.equal({
                message_type: 'kafka'
            });
            return function () {

                done();
            };
        };

        const module = {
            Producer: class {

                send(payloads, cb) {

                    const cli = new module.KafkaClient();
                    cli.brokerForLeader();
                    cb();
                }
            },
            KafkaClient: class {

                brokerForLeader() {

                    return {
                        socket: {
                            host: '127.0.0.1'
                        }
                    };
                }
            }
        };

        KafkaNodeProducerTransport({ module, identity: {}, request: 'kafka-node' }, iFace);
        KafkaNodeProducerTransport({ module, identity: {}, request: './lib' }, iFace);
        const prod = new module.Producer();
        prod.send([{ topic: 'test' }], () => {});
    });
});
