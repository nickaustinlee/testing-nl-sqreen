/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');
const MongoClientTransport = require('../../../lib/transport/mongodb.client');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('mongodb', () => {

    it('should cover client.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['host']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ host: 'localhost' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            if (!holder[key]) {
                return;
            }

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = class {

            constructor(opts) {

                this.s = { topology: { s: opts } };
            }

            replaceOne(query, cb) {

                return cb(null, {}); // TODO: e2e test promise flow!
            }
        };

        MongoClientTransport({ module, request: 'mongodb', identity: { name: 'mongodb' } }, iFace);
        MongoClientTransport({ module, request: './collection', identity: { name: 'mongodb' } }, iFace);

        const client = new module({
            host: 'localhost'
        });

        client.replaceOne({},  (_, results) => {

            expect(results).to.equal({});
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover client.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['ip']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ ip: '127.0.0.1' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            if (!holder[key]) {
                return;
            }

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = class {

            constructor(opts) {

                this.s = { topology: { s: opts } };
            }

            replaceOne(query, cb) {

                return cb(null, {}); // TODO: e2e test promise flow!
            }
        };

        MongoClientTransport({ module, request: 'mongodb', identity: { name: 'mongodb' } }, iFace);
        MongoClientTransport({ module, request: './collection', identity: { name: 'mongodb' } }, iFace);

        const client = new module({
            host: '127.0.0.1'
        });

        client.replaceOne({},  (_, results) => {

            expect(results).to.equal({});
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover client.query', { plan: 2 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: []
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            if (!holder[key]) {
                return;
            }

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = class {

            constructor(opts) {

                this.s = { topology: { s: opts } };
            }

            replaceOne(query, cb) {

                return cb(null, {}); // TODO: e2e test promise flow!
            }
        };

        MongoClientTransport({ module, request: 'mongodb', identity: { name: 'mongodb' } }, iFace);
        MongoClientTransport({ module, request: './collection', identity: { name: 'mongodb' } }, iFace);

        const client = new module({
            host: '127.0.01'
        });

        client.replaceOne({},  (_, results) => {

            expect(results).to.equal({});
            done();
        });

    });
});
