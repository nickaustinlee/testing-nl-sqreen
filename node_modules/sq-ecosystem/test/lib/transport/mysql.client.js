/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');
const MysqlClientTransport = require('../../../lib/transport/mysql.client');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('mysql', () => {

    it('should cover connection.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['host']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ host: 'localhost' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const ConnectionModule = class {

            constructor(conf) {

                this.config = conf;
            }

            query(sql, values, cb) {

                if (typeof values === 'function') {
                    cb = values;
                }
                return cb(null, []);
            }
        };
        MysqlClientTransport({ module: ConnectionModule, request: './lib/Connection', identity: { name: 'mysql' } }, iFace);

        const MySQL = {
            createConnection: function (opts) {

                return new ConnectionModule(opts);
            }
        };
        const connection = MySQL.createConnection({
            host: 'localhost',
            user: 'user',
            password: 'toor',
            database: 'db'
        });

        connection.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal([]);
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover connection.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['ip']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ ip: '127.0.0.1' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const ConnectionModule = class {

            constructor(conf) {

                this.config = conf;
            }

            query(sql, values, cb) {

                if (typeof values === 'function') {
                    cb = values;
                }
                return cb(null, []);
            }
        };
        MysqlClientTransport({ module: ConnectionModule, request: './lib/Connection', identity: { name: 'mysql' } }, iFace);

        const MySQL = {
            createConnection: function (opts) {

                return new ConnectionModule(opts);
            }
        };
        const connection = MySQL.createConnection({
            host: '127.0.0.1',
            user: 'user',
            password: 'toor',
            database: 'db'
        });

        connection.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal([]);
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover createConnection.query', { plan: 3 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: []
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const ConnectionModule = class {

            constructor(conf) {

                this.config = {
                    connectionConfig: conf
                };
            }

            query(sql, values, cb) {

                if (typeof values === 'function') {
                    cb = values;
                }
                return cb(null, []);
            }
        };


        const MySQL = {
            createConnection: function (opts) {

                return new ConnectionModule(opts);
            }
        };

        MysqlClientTransport({ module: MySQL, request: 'mysql', identity: { name: 'mysql' } }, iFace);
        MysqlClientTransport({ module: ConnectionModule, request: './lib/Connection', identity: { name: 'mysql' } }, iFace);

        const connection = MySQL.createConnection({
            host: '127.0.0.1',
            user: 'user',
            password: 'toor',
            database: 'db'
        });

        connection.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal([]);
            expect(token).to.equal(false);
            done();
        });

    });
});
