/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');
const PGClientTransport = require('../../../lib/transport/pg.client');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('pg', () => {

    it('should cover client.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['host']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ host: 'localhost' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = {
            Client: class {

                constructor(opts) {

                    Object.assign(this, opts);
                }

                query(sql, cb) {

                    return cb(null, {}); // TODO: e2e test promise flow!
                }

            },
            Pool: class {

                constructor(opts) {

                    this.options = opts;
                }

                query(sql, cb) {

                    return cb(null, {}); // TODO: e2e test promise flow!
                }

            }
        };

        PGClientTransport({ module, request: 'pg', identity: { name: 'pg' } }, iFace);

        const client = new module.Client({
            user: 'user',
            host: 'localhost',
            database: 'db',
            password: 'toor'
        });

        client.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal({});
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover client.query', { plan: 4 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: ['ip']
            };
        };
        let token = false;
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            expect(resolved).to.equal({ ip: '127.0.0.1' });
            return function () {

                token = true;
            };
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = {
            Client: class {

                constructor(opts) {

                    Object.assign(this, opts);
                }

                query(sql, cb) {

                    return cb(null, {}); // TODO: e2e test promise flow!
                }

            },
            Pool: class {

                constructor(opts) {

                    this.options = opts;
                }

                query(sql, cb) {

                    return cb(null, {}); // TODO: e2e test promise flow!
                }

            }
        };

        PGClientTransport({ module, request: 'pg', identity: { name: 'pg' } }, iFace);

        const client = new module.Client({
            user: 'user',
            host: '127.0.0.1',
            database: 'db',
            password: 'toor'
        });

        client.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal({});
            expect(token).to.equal(true);
            done();
        });

    });

    it('should cover client.query', { plan: 2 }, (done) => {

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

            expect(scope).to.equal('client');
            return {
                trigger: {},
                fields: []
            };
        };
        iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

            throw new Error();
        };

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, _, __, pre, ____, asyncPost) {

            Shimmer.wrap(holder, key, (o) => {

                return function () {

                    pre.method(arguments, undefined, undefined, this);
                    const args = arguments;
                    const cb = arguments[1];
                    arguments[1] = function () {

                        asyncPost.method(args, arguments, undefined);
                        return cb.apply(this, arguments);
                    };
                    o.apply(this, arguments);
                };
            });
        };

        const module = {
            Client: class {

                constructor(opts) {

                    Object.assign(this, opts);
                }

                query(sql, cb) {

                    return cb(null, {});
                }

            }
        };

        PGClientTransport({ module, request: 'pg', identity: { name: 'pg' } }, iFace);
        PGClientTransport({ module, request: './lib', identity: { name: 'pg' } }, iFace);

        const client = new module.Client({
            user: 'user',
            host: '127.0.0.1',
            database: 'db',
            password: 'toor'
        });

        client.query('SELECT 1 + 1 AS solution',  (_, results) => {

            expect(results).to.equal({});
            done();
        });

    });


});
