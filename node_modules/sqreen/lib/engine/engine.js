'use strict';
const SEP = '$';

/**
 * @param {string[]} fields
 */
const getKey = function (fields) {

    return fields.sort().join(SEP);
};

const SubscriptionGroup = module.exports.SubscriptionGroup = class {

    /**
     *
     * @param {string[]} fields
     * @return {SubscriptionGroup}
     */
    static getSubscriptionGroup(fields) {

        const hash = getKey(fields);
        return this.current.get(hash);
    }

    /**
     *
     * @param {string[]} fields
     * @return {SubscriptionGroup}
     */
    static getOrCreateSubscriptionGroup(fields) {

        const hash = getKey(fields);
        let group = this.current.get(hash);
        if (group === undefined) {
            group = new SubscriptionGroup(hash, fields);
            this.current.set(hash, group);
        }
        return group;
    }

    constructor(hash, fields) {

        this.hash = getKey(fields);
        this.callbacks = [];
        this.fields = fields;
    }

    addCB(callback) {

        this.callbacks.push(callback);
    }

    hasCallbacks() {

        return this.callbacks.length !== 0;
    }

    removeCB(callback) {

        this.callbacks = this.callbacks.filter((cb) => cb !== callback);
        if (this.hasCallbacks() === false) {
            SubscriptionGroup.current.delete(this.hash); // remove self if there are no cbs anymore
        }
    }
};
SubscriptionGroup.current = new Map();

module.exports.SubscriptionManager = class {

    constructor() {

        /**
         * @type {Map<string, SubscriptionGroup[]>}
         */
        this.keyToSubscriptionGroups = new Map();
        this.allKeys = new Set();
        this.groupSet = new Set();
    }

    removeAllGroups() {

        this.keyToSubscriptionGroups = new Map();
        this.allKeys = new Set();
        this.groupSet = new Set();
    }

    addGroup(group) {

        if (this.groupSet.has(group)) {
            return;
        }

        for (let i = 0; i < group.fields.length; ++i) {
            const key = group.fields[i];
            this.allKeys.add(key);
            let list = this.keyToSubscriptionGroups.get(key);
            if (list === undefined) {
                list = [];
                this.keyToSubscriptionGroups.set(key, list);
            }
            list.push(group);
        }
        this.groupSet.add(group);
    }

    /**
     * /!\ This method is very costly
     */
    rebuildKeySet() {

        const groupSet = new Set(Array.from(this.keyToSubscriptionGroups.values()).reduce((a, b) => a.concat(b), []));
        const res = this.allKeys = new Set();
        groupSet.forEach((group) => group.fields.forEach(res.add, res));
    }

    /**
     * /!\ This method is very costly
     */
    removeGroupSet(groupSet) {

        groupSet.forEach((group) => {

            //$lab:coverage:off$
            if (!this.groupSet.has(group)) {
                return;
                //$lab:coverage:on$
            }
            this.groupSet.delete(group);

            for (let i = 0; i < group.fields.length; ++i) {
                const key = group.fields[i];
                const associatedGroups = this.keyToSubscriptionGroups.get(key);
                //$lab:coverage:off$
                if (associatedGroups === undefined) {
                    continue;
                    //$lab:coverage:on$
                }
                const newAssociatedGroups = associatedGroups.filter((x) => x !== group);
                this.keyToSubscriptionGroups.set(key, newAssociatedGroups);
            }
        });
        this.rebuildKeySet();
    }

    extractGroups(keyList, allKeys) {

        const cbSet = new Set();
        const keySet = new Set();
        const knowGroups = new Set();
        for (let i = 0; i < keyList.length; ++i) {
            const groups = this.keyToSubscriptionGroups.get(keyList[i]);
            if (groups === undefined) {
                continue;
            }
            for (let j = 0; j < groups.length; ++j) {
                const group = groups[j];
                if (knowGroups.has(group) === true) {
                    continue; // we already have handled this ons
                }
                knowGroups.add(group);
                const isValid = group.fields.every((k) => allKeys.indexOf(k) > -1);
                if (isValid === true) {
                    group.fields.forEach(keySet.add, keySet);
                    group.callbacks.forEach(cbSet.add, cbSet);
                }
            }
        }
        return { keySet, cbSet };
    }

    /**
     * @param {string[]} keyList
     * @param {Span} span
     */
    dispatch(keyList, span) {

        const result = this.extractGroups(span.keys, keyList);
        const cbSet = result.cbSet;
        const keySet = result.keySet;
        const params = {};
        keySet.forEach((key) => {

            params[key] = span.resolve(key);
        });
        const cbResults = [];
        cbSet.forEach((cb) => {

            cbResults.push(cb(params));
        });
        return cbResults;
    }
};

const Span = module.exports.Span = class {

    static setManager(manager) {

        this.manager = manager;
    }

    createChild() {

        const parents = Array.from(this.parents);
        parents.push(this);
        return new Span(parents);
    }

    /**
     *
     * @param {Span[]} parents
     */
    constructor(parents) {

        /**
         * @type {Span[]}
         */
        this.parents = parents; // parent can be empty
        /**
         *
         * @type {Map<string, any>}
         */
        this.store = new Map();
        /**
         *
         * @type {string[]}
         */
        this.keys = [];
        this.initAllKeys();
    }

    initAllKeys() {

        const parentsLn = this.parents.length;
        this.allKeys = parentsLn > 0 ? Array.from(this.parents[parentsLn - 1].keys) : []; // Array.from is a faster solution it seems
    }

    cleanup() {

        this.initAllKeys();
        this.store = new Map();
        this.keys = [];
    }

    /**
     *
     * @param {string} key
     * @param {any} value
     * @return {Span}
     */
    setValue(key, value) {

        this.store.set(key, value);
        if (this.keys.indexOf(key) > -1) {
            return this;
        }
        this.keys.push(key);
        this.allKeys.push(key);
        return this;
    }

    setMultipleValues(params) {

        const keyList = Object.keys(params);
        for (let i = 0; i < keyList.length; ++i) {
            const k = keyList[i];
            this.setValue(k, params[k]);
        }
        return this;
    }

    /**
     * @return {string[]}
     */
    getallKeys() {

        return this.allKeys;
    }

    dispatch() {

        return Span.manager.dispatch(this.getallKeys(), this);
    }

    resolve(key) {

        if (this.store.has(key) === true) {
            return this.store.get(key);
        }
        for (let i = this.parents.length - 1; i >= 0; --i) {
            const parent = this.parents[i]; // I don't want to use a reccursive loop here. I am not sure why
            if (parent.store.has(key) === true) {
                return parent.store.get(key);
            }
        }
    }
};

