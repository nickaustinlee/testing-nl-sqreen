'use strict';
const Event = require('events');
const Code = require('code');
const expect = Code.expect;
const ensureState = function () {
    // ensure the CLS is not loaded
    expect(process.addEventListener, 'process.addEventListener').to.not.exist();
};
ensureState();

// run these tests only if the version of Node is >= 8.2.0
const Semver = require('semver');
if (!Semver.satisfies(process.version, '>= 8.2.0')) {
    return;
}

const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const beforeEach = lab.beforeEach;
const afterEach = lab.afterEach;

const CLS = require('../lib/instrumentation/hooks/clsAH');

const namespaceName = 'sqreen_session';

describe('CLS Async Hooks', () => {

    beforeEach((done) => {

        ensureState();
        done();
    });

    afterEach((done) => {

        try {
            CLS.destroyNamespace(namespaceName);
        }
        catch (_) {}
        done();
    });

    it('should trigger coverage on removeAsyncListener', { plan: 0 }, (done) => {

        CLS.removeAsyncListener(-1);
        done();
    });

    it('should handle exception in run cb', { plan: 2 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        try {
            session.run(() => {

                throw new Error('my error');
            });
        }
        catch (err) {
            expect(err).to.exist();
        }

        try {
            session.run(() => {

                throw null;
            });
        }
        catch (err) {
            expect(err).to.equal(null);
        }
        done();
    });

    it('should test runAndReturn', { plan: 1 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        session.run(() => {

            expect(session.runAndReturn(() => 1)).to.equal(1);
            done();
        });
    });

    it('should test bind', { plan: 4 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        const holder = {
            fct0: function (x, cb) {

                return cb(x);
            },
            fct1: function () {

                throw new Error('ok');
            },
            fct2: function () {

                throw null;
            }
        };

        session.bind(holder.fct0)(1, (p) => {

            expect(p).to.equal(1);
            expect(process.sqreen_namespaces[namespaceName].active).to.exist();
        });

        try {
            session.bind(holder.fct1)();
        }
        catch (err) {
            expect(err).to.exist();
        }

        try {
            session.bind(holder.fct2)();
        }
        catch (err) {
            expect(err).to.equal(null);
        }
        done();
    });

    it('should not allow to set value out of context', { plan: 1 }, (done) => {

        const session = CLS.createNamespace(namespaceName);
        try {
            session.set('1', 1);
        }
        catch (err) {
            expect(err).to.exist();
            done();
        }
    });

    it('should keep the context', { plan: 2 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        session.run(() => {

            session.set('a', 1);
            expect(session.get('a')).to.equal(1);

            process.nextTick(() => {

                expect(session.get('a')).to.equal(1);

                done();
            });
        });
    });

    it('should keep the context between different tracks', { plan: 4 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        const end = new Event();
        let count = 0;
        end.on('data', () => {

            count++;
            if (count === 2) {
                done();
            }
        });

        session.run(() => {

            session.set('a', 1);
            expect(session.get('a')).to.equal(1);

            setTimeout(() => {

                expect(session.get('a')).to.equal(1);
                end.emit('data');
            }, 500);
        });

        session.run(() => {

            session.set('a', 2);
            expect(session.get('a')).to.equal(2);

            setTimeout(() => {

                expect(session.get('a')).to.equal(2);
                end.emit('data');
            }, 10);
        });
    });

    it('should bind in current context', { plan: 3 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        session.run(() => {

            session.set('a', 2);
            expect(session.get('a')).to.equal(2);

            setTimeout(() => {

                expect(session.get('a')).to.equal(2);

                session.bind(() => {

                    expect(session.get('a')).to.equal(2);
                    done();
                })();

            }, 10);
        });
    });

    it('should handle multiple contexts', { plan: 1 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        const a1 = {};
        const a2 = {};
        session._set.push(a1);
        session._set.push(a2);
        session.exit(a2);
        expect(session._set).to.have.length(1);
        done();
    });

    it('should handle reset', { plan: 0 }, (done) => {

        CLS.createNamespace(namespaceName);
        CLS.reset();
        done();
    });

    it('should cover bindEmitter', { plan: 2 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        try {
            session.bindEmitter({});
        }
        catch (err) {
            expect(err).to.exist();
        }

        try {
            session.bindEmitter({ on: 1 });
        }
        catch (err) {
            expect(err).to.exist();
        }
        done();
    });

    it('should handle what happens in an emitter', { plan: 2 }, (done) => {

        const session = CLS.createNamespace(namespaceName);
        const emitter = new Event();

        expect(session.get('a')).to.not.exist();
        emitter.on('hello', () => {

            expect(session.get('a')).to.equal('aaa');
            done();
        });

        session.run(() => {

            session.bindEmitter(emitter);
            session.set('a', 'aaa');
            emitter.emit('hello');
        });
    });

    it('should test our cls with async/await calls', { plan: 2 }, (done) => {

        // we can't use async/await directly because of tests on older nodejs versions...
        const Vm = require('vm');
        const context = {};
        Vm.runInNewContext('async function action() { await Promise.resolve(); return true; }', context);

        const session = CLS.createNamespace(namespaceName);
        session.run(() => {

            session.set('a', 10);
            context.action()
                .then((v) => {

                    expect(v).to.be.true();
                    expect(session.get('a')).to.equal(10);
                    done();
                });
        });
    });

    it('should perform a CLS AH lifecycle', { plan: 2 }, (done) => {

        const session = CLS.createNamespace(namespaceName);
        const clsMap = Array.from(CLS.getMap().values()).pop();
        session.run(() => {

            const req = {};
            session.set('req', req);
            session.set('req', req);

            req.cachedPromise = new Promise((resolve) => { // introduce an async hook leak

                const tenMebibyteString = 'a'.repeat(10 * 1024 * 1024);
                resolve(tenMebibyteString);
            });

            process.nextTick(() => {

                expect(clsMap.store.size).to.be.above(1);
                process.sqreenAsyncListener.cleanup(req);
                expect(clsMap.store.size).to.equal(0);
                done();
            });
        });
    });

    it('should cover error cases', { plan: 0 }, (done) => {

        const session = CLS.createNamespace(namespaceName);
        const clsMap = Array.from(CLS.getMap().values()).pop();
        session.run(() => {

            const req = {};
            session.set('req', req);
            session.set('req', req);

            req.cachedPromise = new Promise((resolve) => { // introduce an async hook leak

                const tenMebibyteString = 'a'.repeat(10 * 1024 * 1024);
                resolve(tenMebibyteString);
            });

            process.nextTick(() => {

                clsMap.error();
                clsMap.error(CLS.getNamespace(namespaceName));
                done();
            });
        });
    });

    it('should test a proper exit case', { plan: 3 }, (done) => {

        const req = {};
        const ok = new Event();

        ok.on('done', () => {

            const ns = CLS.getNamespace(namespaceName);
            expect(ns._set).to.have.length(1);
            expect(ns._set).to.equal([null]);

            done();
        });

        const session = CLS.createNamespace(namespaceName);
        const clsMap = Array.from(CLS.getMap().values()).pop();
        session.run(() => {

            session.set('req', req);
            session.set('req', req);

            process.nextTick(() => {

                expect(clsMap.store.size).to.be.above(0);
                process.sqreenAsyncListener.cleanup({});
                process.sqreenAsyncListener.cleanup(req);

                session.exit(session);
                ok.emit('done');
            });
        });
    });

    it('should should ensure cleanup does not mess anything too much', { plan: 9 }, (done) => {

        const session = CLS.createNamespace(namespaceName);

        const req1 = {};
        const req2 = {};
        let cup = false;
        session.run(() => {

            session.set('req', req1);
            setTimeout(() => {

                expect(session.get('req')).to.equal(req1);
                process.sqreenAsyncListener.cleanup(req1);
                cup = true;
                process.nextTick(() => {

                    expect(session.get('req')).to.equal(null);
                });
            }, 30);

            process.nextTick(() => {

                expect(session.get('req')).to.equal(req1);
                setTimeout(() => {

                    expect(session.get('req')).to.equal(null);
                }, 40);
            });
        });

        session.run(() => {

            session.set('req', req2);
            setTimeout(() => {

                expect(session.get('req')).to.equal(req2);
                setTimeout(() => {

                    expect(cup).to.be.true();
                    expect(session.get('req')).to.equal(req2);
                    setTimeout(() => {

                        expect(cup).to.be.true();
                        expect(session.get('req')).to.equal(req2);
                        done();
                    }, 10);
                }, 50);
            }, 10);
        });

    });
});

