/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Agent = require('../../../lib/agent/index');
const Proxyquire = require('proxyquire');
const Shimmer = require('shimmer');
const Backend = require('../../../lib/backend');

describe('Agent', () => {

    describe('STARTED', () => {

        it('should return false', { plan: 2 }, (done) => {

            const started = Agent.STARTED();
            expect(started).to.be.a.boolean();
            expect(started).to.be.false();
            done();
        });
    });

    describe('SESSION_ID', () => {

        it('should return undefined', { plan: 1 }, (done) => {

            const started = Agent.SESSION_ID();
            expect(started).to.not.exist();
            done();
        });
    });

    describe('heartBeatWorker', () => {

        it('should send a heartbeat and get an empty command list', { plan: 1 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent._heartBeatWorker()
                .then(() => {

                    done();
                });
        });

        it('should send a heartbeat and get an empty command list', { plan: 1 }, (done) => {

            require('../../../lib/command/features').featureHolder.use_signals = false;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent._heartBeatWorker()
                .then(() => {

                    require('../../../lib/command/features').featureHolder.use_signals = true;
                    done();
                });
        });

        it('should send a heartbeat and get a command list', { plan: 2 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [{ name: 'mock' }] });
                    }
                },
                '../command': {
                    execute: function (command) {

                        expect(command.name).to.equal('mock');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent._heartBeatWorker()
                .then(() => {

                    done();
                });
        });

        it('should send a heartbeat and get a command list then execute a failed command', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [{ name: 'mock' }] });
                    }
                },
                '../command': {
                    execute: function (command) {

                        expect(command.name).to.equal('mock');
                        return Promise.reject('my err');
                    }
                },
                '../exception': {
                    report: function (err) {

                        expect(err).to.equal('my err');
                        done();
                        return Promise.reject();
                    }
                }
            });

            MockedAgent._heartBeatWorker();
        });

        it('should fail at sending a heartbeat', { plan: 2 }, (done) => {

            const ERR = new Error('mock');
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.reject(ERR);
                    }
                },
                '../exception': {
                    report: function (err) {

                        expect(err).to.equal(ERR);
                        done();
                        return Promise.reject();
                    }
                }
            });

            MockedAgent._heartBeatWorker();
        });

    });

    describe('heartBeatLoopStarter', () => {

        it('should set-up an interval', { plan: 3 }, (done) => {

            let counter = 0;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        counter++;
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            const interval = MockedAgent._startHeartBeatLoop(100);
            expect(interval).to.exist();


            setTimeout(() => {

                expect(counter).to.be.above(7);
                expect(counter).to.be.below(12);
                clearInterval(interval);
                done();
            }, 1000);
        });

        it('should set-up an overrriden interval', { plan: 1 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../config/index': {
                    getConfig: function () {

                        return { heartbeat_delay: 100 };
                    }
                },
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            const interval = MockedAgent._startHeartBeatLoop(100);
            expect(interval).to.exist();
            clearInterval(interval);
            done();
        });
    });

    describe('heartBeatLoopStarter', () => {

        it('should start the heartbeat loop and change timming after a while', { plan: 2 }, (done) => {

            let counter = 0;
            Shimmer.wrap(Backend, 'heartBeat', () => {

                return function () {

                    ++counter;
                    return Promise.resolve({ commands: [] });
                };
            });

            Agent.heartBeatLoopStarter({ firstInterval: 50, secondInterval: 120, changeIntervalAfter: 100 });

            setTimeout(() => {

                expect(counter).to.be.at.least(2);
                expect(counter).to.be.below(4);
                Agent._clearAll();
                Backend.heartBeat.__unwrap();
                done();
            }, 250);

        });

        it('should start the heartbeat loop', { plan: 2 }, (done) => {

            let counter = 0;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        counter++;
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent.heartBeatLoopStarter({ firstInterval: 50 });

            setTimeout(() => {

                expect(counter).to.be.at.least(4);
                expect(counter).to.be.below(6);
                MockedAgent._clearAll();
                done();
            }, 250);

        });
    });

    describe('start', () => {

        it('should start the agent without error', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                    done();
                });
        });

        it('should start the agent without error and without double call', { plan: 4 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                }
            });

            const call1 = MockedAgent.start({ token: 'token' });
            const call2 = MockedAgent.start({ token: 'token' });
            call1
                .then(() => {

                    expect(call1).to.equal(call2);
                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                    done();
                });
        });

        it('should start the agent without error with default values 0', { plan: 5 }, (done) => {

            let run = true; // prevent another test to sent another message
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                },
                '../command/features': {
                    read: function () {

                        return {};
                    }
                },
                '../agent_message/index': function (kind, message, infos) {

                    if (!run) {
                        return {
                            report() {

                                return Promise.resolve();
                            }
                        };
                    }

                    expect(message).to.equal(`The following modules were required before Sqreen. Sqreen may not be able to protect the whole application.
- aa
If you think this is an error, please report it to Sqreen team.`);
                    expect(infos).to.equal({ libs: ['aa'] });
                    return {
                        report: function () {

                            run = false;
                            done();
                            return Promise.resolve();
                        }
                    };
                }
            });

            MockedAgent.start({ token: 'token' }, ['aa'])
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                });
        });

        it('should start the agent without error with default values', { plan: 5 }, (done) => {

            let run = true; // prevent another test to sent another message
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            heartbeat_delay: 10
                        };
                    }
                },
                '../agent_message/index': function (kind, message, infos) {

                    if (!run) {
                        return {
                            report() {

                                return Promise.resolve();
                            }
                        };
                    }

                    expect(message).to.equal(`The following modules were required before Sqreen. Sqreen may not be able to protect the whole application.
- aa
If you think this is an error, please report it to Sqreen team.`);
                    expect(infos).to.equal({ libs: ['aa'] });
                    return {
                        report: function () {

                            run = false;
                            done();
                            return Promise.resolve();
                        }
                    };
                }
            });

            MockedAgent.start({ token: 'token' }, ['aa'])
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                });
        });

        it('should catch double loaded signals', { plan: 2 }, (done) => {

            let run = true; // prevent another test to sent another message
            Proxyquire('../../../lib/agent/index', {
                '../agent_message/index': function (kind, message, infos) {

                    if (!run) {
                        return {
                            report() {

                                return Promise.resolve();
                            }
                        };
                    }

                    expect(message).to.equal('Sqreen agent has been loaded twice in the application. The second instance will be ignored and SDK calls will be reported to first loaded agent.\n'
                        + 'Sqreen can behave in unexpected manner.\n'
                        + 'Active Sqreen agent version v70 - disabled agent is version v55.');
                    expect(infos).to.equal({});
                    return {
                        report: function () {

                            run = false;
                            done();
                            return Promise.resolve();
                        }
                    };
                }
            });

            process.emit('sqreen_loaded_twice', { current: 'v55', existing: 'v70' });
        });

        it('should fail to start the agent', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.reject();
                    }
                }
            });

            MockedAgent.start({ token: 'token' }, {})
                .catch(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist('session');
                    MockedAgent._clearAll();
                    done();
                });
        });
    });

    describe('stop', () => {

        it('should stop the agent', { plan: 6 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent.start({ token: 'token' }, 'aa')
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    done();
                });
        });

        it('should stop the agent', { plan: 6 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.reject();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.exist();
                    done();
                });
        });

        it('should try to stop the agent that is already stopped', { plan: 2 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    logout: function () {

                        done(new Error('this should not have been called'));
                    }
                }
            });

            MockedAgent.stop('session')
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    done();
                });
        });

        it('should stop the agent', { plan: 6 }, (done) => {

            const env = process.env.NODE_ENV;

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    delete process.env.NODE_ENV;
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    process.env.NODE_ENV = env;
                    done();
                });
        });


        it('should try to stop the agent that is in dev', { plan: 2 }, (done) => {

            const env = process.env.NODE_ENV;
            process.env.NODE_ENV = 'dev';

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    logout: function () {

                        done(new Error('this should not have been called'));
                    }
                }
            });

            MockedAgent.stop('session')
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    process.env.NODE_ENV = env;
                    done();
                });
        });
    });
});
