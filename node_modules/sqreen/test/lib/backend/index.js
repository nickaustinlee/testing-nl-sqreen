/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const Shimmer = require('shimmer');

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Os = require('os');

let BackEnd;

describe('BackEnd', () => {

    describe('_LoggedRp', () => {

        it('should reject unhandled http verbs', { plan: 1, timeout: 15000 }, () => {

            BackEnd = require('../../../lib/backend');
            return BackEnd._LoggedRp({ method: 'PATCH' })
                .catch((err) => {

                    expect(err.message).to.equal('unhandled verb PATCH');
                    return Promise.resolve();
                });
        });
    });

    describe('handleResponse', () => {

        it('should create a default response', { plan: 1 }, (done) => {

            BackEnd = require('../../../lib/backend');
            BackEnd._handleResponse(null)
                .then((r) => {

                    expect(r).to.equal({ status: 'ok' });
                    done();
                });
        });
    });

    describe('login', () => {

        it('should login to a server', { plan: 16 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v1/app-login');
                        expect(options.headers['x-api-key']).to.equal('token');

                        expect(pl).to.includes(['agent_type', 'agent_version', 'os_type', 'hostname', 'runtime_type', 'runtime_version', 'framework_type', 'framework_version', 'environment', 'various_infos']);
                        expect(pl.agent_type).to.equal('nodejs');
                        // expect(pl.agent_version).to.equal(require('../../../package.json').version);
                        expect(pl.hostname).to.equal(Os.hostname());
                        expect(pl.os_type).to.includes(Os.arch());
                        expect(pl.os_type).to.includes(Os.type());
                        expect(pl.runtime_type).to.equal('node');
                        expect(pl.runtime_version).to.equal(process.version);
                        expect(pl.framework_type).to.equal('');
                        expect(pl.framework_version).to.not.exist();
                        expect(pl.environment).to.equal('test');
                        // expect(pl.various_infos.declared_dependencies).to.equal(require('../../../package.json').dependencies);
                        // expect(pl.various_infos.declared_devdependencies).to.equal(require('../../../package.json').devDependencies);
                        expect(pl.various_infos).to.includes(['time', 'pid', 'euid', 'name']);
                        expect(pl.bundle_signature).to.be.a.string();
                        expect(pl.bundle_signature.length).to.equal(40);

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            BackEnd.login('token')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                })
                .catch((err) => done(err));
        });

        it('should login to a server on v1', { plan: 6 }, (done) => {

            const MockedBackend = Proxyquire('../../../lib/backend/index', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.resolve({
                            status: true,
                            session_id: 'session-key',
                            commands: [{ name: 'a' }],
                            features: { myFeature: 'hello' },
                            rules: [{ name: 'rule' }],
                            actions: [1],
                            pack_id: 'a',
                            known_agent_messages: ['a']
                        });
                    }
                },
                '../command': {
                    execute: function (cmd) {

                        expect(cmd.name).to.equal('a');
                        return Promise.resolve();
                    }
                },
                '../command/features': {
                    change: function (ft) {

                        expect(ft.myFeature).to.equal('hello');
                    }
                },
                '../actions': {
                    enforceActionList(list) {

                        expect(list).to.equal([1]);
                    }
                },
                '../rules': {
                    enforceRuleList: function (list) {

                        expect(list[0].name).to.equal('rule');
                        expect(list[0].rulesPack).to.equal('a');
                    }
                },
                '../agent_message/index': {
                    initKnownMessages: function (list) {

                        expect(list).to.have.length(1);
                    }
                }

            });

            MockedBackend.login('token')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                });
        });

        it('should login to a server on v1 without name', { plan: 6 }, (done) => {

            const MockedBackend = Proxyquire('../../../lib/backend/index', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.resolve({
                            status: true,
                            session_id: 'session-key',
                            commands: [{ name: 'a' }],
                            features: { myFeature: 'hello' },
                            rules: [{ name: 'rule' }],
                            actions: [1],
                            pack_id: 'a',
                            known_agent_messages: ['a']
                        });
                    }
                },
                '../command': {
                    execute: function (cmd) {

                        expect(cmd.name).to.equal('a');
                        return Promise.resolve();
                    }
                },
                '../command/features': {
                    change: function (ft) {

                        expect(ft.myFeature).to.equal('hello');
                    }
                },
                '../actions': {
                    enforceActionList(list) {

                        expect(list).to.equal([1]);
                    }
                },
                '../rules': {
                    enforceRuleList: function (list) {

                        expect(list[0].name).to.equal('rule');
                        expect(list[0].rulesPack).to.equal('a');
                    }
                },
                '../agent_message/index': {
                    initKnownMessages: function (list) {

                        expect(list).to.have.length(1);
                    }
                },
                './login': {
                    getPayload: function () {

                        return Promise.resolve({});
                    }
                }

            });

            MockedBackend.login('token')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                });
        });

        it('should login to a server on v1 with app name', { plan: 7 }, (done) => {

            const MockedBackend = Proxyquire('../../../lib/backend/index', {
                './wreckAsPromised': {
                    POST: function (url, headers) {

                        expect(headers).to.equal({ headers: { 'x-api-key': 'token', 'x-app-name': 'app_name' } });

                        return Promise.resolve({
                            status: true,
                            session_id: 'session-key',
                            commands: [{ name: 'a' }],
                            features: { myFeature: 'hello' },
                            rules: [{ name: 'rule' }],
                            actions: [1],
                            pack_id: 'a',
                            known_agent_messages: ['a']
                        });
                    }
                },
                '../command': {
                    execute: function (cmd) {

                        expect(cmd.name).to.equal('a');
                        return Promise.resolve();
                    }
                },
                '../command/features': {
                    change: function (ft) {

                        expect(ft.myFeature).to.equal('hello');
                    }
                },
                '../actions': {
                    enforceActionList(list) {

                        expect(list).to.equal([1]);
                    }
                },
                '../rules': {
                    enforceRuleList: function (list) {

                        expect(list[0].name).to.equal('rule');
                        expect(list[0].rulesPack).to.equal('a');
                    }
                },
                '../agent_message/index': {
                    initKnownMessages: function (list) {

                        expect(list).to.have.length(1);
                    }
                }

            });

            MockedBackend.login('token', 'app_name')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                });
        });

        it('should fail to login to a server', { plan: 1, timeout: 60000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.reject({ status: false });
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                }
            });


            BackEnd.login('token')
                .then(() => done(new Error('this should have failed')))
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should fail to login to a server because of bad token', { plan: 1, timeout: 60000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.resolve({
                            message: {
                                error: 'Token validation failure'
                            },
                            status: false
                        });
                    }

                }
            });


            BackEnd.login('token')
                .then(() => {


                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();

                    done();
                });
        });
    });

    describe('logout', () => {

        it('should logout a user', { plan: 3 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/app-logout');
                        expect(options.headers['x-session-key']).to.equal('session');

                        return Promise.resolve({ status: true });
                    }

                }
            });


            BackEnd.logout('session')
                .then((response) => {

                    expect(response).to.exist();

                    done();
                })
                .catch((err) => {

                    done(err);
                });
        });

        it('should fail to logout a user because of error 500', { plan: 1, timeout: 300 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function () {

                        return Promise.reject({ status: false });
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                }
            });

            BackEnd.logout('token')
                .then(() => {

                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();

                    done();
                });
        });

        it('should fail to logout a user because of false status in payload', { plan: 1, timeout: 30000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function () {

                        return Promise.resolve({ status: false });
                    }
                }
            });

            BackEnd.logout('token')
                .then(() => {


                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });
    });

    describe('others', () => {

        it('should test heartbeat', { plan: 5 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v1/app-beat');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();
                        expect(pl.command_results).to.exist();
                        expect(pl.metrics).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.heartBeat('token');
        });

        it('should test an old heartbeat', { plan: 5 }, () => {

            require('../../../lib/command/features').featureHolder.use_signals = false;
            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v1/app-beat');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();
                        expect(pl.command_results).to.exist();
                        expect(pl.metrics).to.exist();

                        require('../../../lib/command/features').featureHolder.use_signals = true;
                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.heartBeat('token');
        });

        it('should test attack', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/attack');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.attack('token', {});
        });

        it('should test request_record', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/request_record');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.request_record('token', {});
        });

        it('should test batch', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/batch');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.batch('token', {});
        });

        it('should test exception', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/sqreen_exception');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.exception('token', {});
        });

        it('should test commands', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/commands');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.commands('token', {});
        });

        it('should test bundle', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/bundle');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.bundle('token', { a: 1 });
        });

        it('should test metrics', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/metrics');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.metrics('token', {});
        });

        it('should test rulespack', { plan: 2 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/rulespack');
                        expect(options.headers['x-session-key']).to.equal('token');

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.rulespack('token');
        });

        it('should test actionspack', { plan: 2 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/actionspack');
                        expect(options.headers['x-session-key']).to.equal('token');

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.actionspack('token');
        });

        it('should test agent_message', { plan: 2 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/agent_message');
                        expect(options.headers['x-session-key']).to.equal('token');

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.agent_message('token', { message: 'hello' });
        });

        it('should test data_point', { plan: 2 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/data_point');
                        expect(options.headers['x-session-key']).to.equal('token');

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.data_point('token', { message: 'hello' });
        });

        it('should test data_point with a 500', { plan: 1 }, () => {

            let count = 0;
            BackEnd = Proxyquire('../../../lib/backend', {
                '../agent': {
                    start: function () {

                        return Promise.resolve();
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                },
                './wreckAsPromised': {
                    POST: function () {

                        count += 1;
                        return Promise.reject({ statusCode: 500 });
                    }

                }
            });

            return BackEnd.data_point('token', { message: 'hello' })
                .catch(() => {

                    expect(count).to.equal(7);
                });
        });

        it('should test data_point with empty error', { plan: 1 }, () => {

            let count = 0;
            BackEnd = Proxyquire('../../../lib/backend', {
                '../agent': {
                    start: function () {

                        return Promise.resolve();
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                },
                './wreckAsPromised': {
                    POST: function () {

                        count += 1;
                        return Promise.reject();
                    }
                }
            });

            return BackEnd.data_point('token', { message: 'hello' })
                .catch(() => {

                    expect(count).to.equal(7);
                });
        });

        it('should test data_point with a 401', { plan: 1 }, () => {

            let count = 0;
            BackEnd = Proxyquire('../../../lib/backend', {
                '../agent': {
                    start: function () {

                        return Promise.resolve();
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                },
                './wreckAsPromised': {
                    POST: function () {

                        count += 1;
                        return Promise.reject({ statusCode: 401 });
                    }

                }
            });

            return BackEnd.data_point('token', { message: 'hello' })
                .catch(() => {

                    expect(count).to.equal(1);
                });
        });
    });

    describe('Reveal', () => {

        it('should cover reveal_runtime', { plan: 1 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (url) {

                        expect(url).to.equal('https://back.sqreen.io/sqreen/v1/reveal/runtime/1');
                        return Promise.resolve({ status: true });
                    }

                }
            });

            return BackEnd.reveal_runtime('token');
        });

        it('should cover reveal_run', { plan: 1 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (url) {

                        expect(url).to.equal('https://back.sqreen.io/sqreen/v1/reveal/run?a=10&b=1&x=hello');
                        return Promise.resolve({ status: true });
                    }

                }
            });

            return BackEnd.reveal_run('token', { a: 10, b: 1, x: 'hello' });
        });

    });

    describe('ping', () => {

        it('should cover ping', { plan: 6 }, (done) => {

            const Message = require('../../../lib/agent_message/index');
            const WAP = require('../../../lib/backend/wreckAsPromised');

            const uris = new Set(['https://back.sqreen.io/ping', 'https://ingestion.sqreen.com/ping']);
            const kinds = new Set(['back_sqreen_com_unavailable', 'ingestion_sqreen_com_unavailable']);
            Shimmer.wrap(WAP, 'GET', () => {

                return function (uri) {

                    expect(uris.has(uri)).to.be.true();
                    return Promise.reject();
                };
            });

            let report = 0;
            Shimmer.wrap(Message.prototype, 'report', () => {

                return function () {

                    expect(kinds.has(this.kind)).to.be.true();
                    ++report;
                    if (report === 2) {
                        Shimmer.unwrap(Message.prototype, 'report');
                        Shimmer.unwrap(WAP, 'GET');
                        done();
                    }
                };
            });
            require('../../../lib/backend/index').pingBacks();
        });
    });
});
