/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Action = require('../../../lib/command/actions');
const Command = require('../../../lib/command/actions');
const Shimmer = require('shimmer');
const Proxyquire = require('proxyquire');

describe('Command.action', () => {

    describe('tracing_collect', () => {

        it('should update tracing rules', { plan: 4 }, () => {

            return Action
                .tracing_enable()
                .catch((e) => {

                    expect(e).to.exist();
                })
                .then(() => Action.tracing_enable([]))
                .catch((e) => {

                    expect(e).to.exist();
                })
                .then(() => Action.tracing_enable([{ foo: { enabled: true } }]))
                .catch((e) => {

                    expect(e).to.exist();
                })
                .then(() => Action.tracing_enable(['', { foo: null }]))
                .catch((e) => {

                    expect(e).to.exist();
                })
                .then(() => Action.tracing_enable(['', { foo: { enabled: true, sampling: [{ calls: 1 }] } }]))
                .then(() => Action.tracing_enable(['', { foo: { enabled: true } }]));
        });
    });

    describe('instrumentation_enable', () => {

        it('should throw since agent is offline', { plan: 1 }, () => {

            require('../../../lib/agent').setSESSION_ID(undefined);

            return Action.instrumentation_enable()
                .catch((err) => {

                    expect(err.message).to.equal('agent is offline');
                });
        });

        it('should ask for a new rulespack but fail to verify them', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ pack_id: 10, rules: [{ a: 1 }] });
                    }
                }
            });

            MockedAction.instrumentation_enable()
                .catch((err) => {

                    expect(err.message).to.equal('invalid rulespack: 10');
                    done();
                });
        });

        it('should ask for a new rulespack but get an empty one', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ rules: [{ a: 1 }] });
                    }
                }
            });

            MockedAction.instrumentation_enable()
                .then((str) => {

                    expect(str).to.equal('');
                    done();
                });
        });

        it('should ask for a new rulespack', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ pack_id: 10, rules: [{ a: 1 }] });
                    }
                },
                '../rules': {
                    enforceRuleList: function () {

                        return true;
                    }
                }
            });

            return MockedAction.instrumentation_enable()
                .then((id) => {

                    expect(id).to.equal(10);
                });
        });


        it('should remove all callbacks', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/patch': {
                    removeAllCallbacks: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                }
            });

            return MockedAction.instrumentation_remove();
        });

        it('should remove all callbacks then logout', { plan: 2 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/patch': {
                    removeAllCallbacks: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                },
                '../agent': {
                    stop: function () {

                        expect(true).to.be.true(); // ensure call
                        return Promise.resolve();
                    }
                }
            });

            return MockedAction.force_logout();
        });
    });

    describe('features_change', () => {

        it('should change features', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                './features': {
                    change: function (params) {

                        expect(params).to.equal({});
                        done();
                    }
                }
            });
            MockedAction.features_change({});
        });
    });

    describe('features_get', () => {

        it('should change features', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                './features': {
                    read: function () {

                        return { hello: 'world' };
                    }
                }
            });
            MockedAction.features_get()
                .then((r) => {

                    expect(r).to.equal({ hello: 'world' });
                    done();
                });
        });
    });

    describe('paths_whitelist', () => {

        it('should reject without params', { plan: 1 }, (done) => {

            Action.paths_whitelist([], '')
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should change whitelist', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/whitelist': {
                    whitelistThesePaths: function (list) {

                        expect(list).to.exist();
                        expect(list).to.equal(['a']);
                        done();
                    }
                }
            });

            MockedAction.paths_whitelist([['a']], '');
        });
    });

    describe('ips_whitelist', () => {

        it('should change whitelist', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/whitelist': {
                    whitelistTheseIPs: function (list) {

                        expect(list).to.exist();
                        expect(list).to.equal(['a']);
                        done();
                    }
                }
            });

            MockedAction.ips_whitelist([['a']], '');
        });
    });

    it('should fail to change whitelist', { plan: 1 }, (done) => {

        Action.ips_whitelist([new Array(1e4 + 1).fill('a')], '')
            .catch((e) => {

                expect(e).to.exist();
                done();
            });
    });

    it('should fail to change whitelist', { plan: 1 }, (done) => {

        Action.ips_whitelist([['a']], '')
            .catch((e) => {

                expect(e).to.exist();
                done();
            });
    });

    describe('get_bundle', () => {

        it('should send the bundle to the BE', { plan: 2 }, (done) => {

            process.env.SQREEN_TOKEN = 'a';
            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../backend': {
                    bundle: function (_, resp) {

                        expect(resp.dependencies.length).to.be.above(250);
                        expect(resp.bundle_signature.length).to.equal(40);
                        delete process.env.SQREEN_TOKEN;
                        done();
                    }
                }
            });

            MockedAction.get_bundle(null, 10);

        });

        it('should send the bundle to the BE w/o declared deps', { plan: 2 }, (done) => {

            process.env.SQREEN_TOKEN = 'a';
            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../backend/login': {
                    getPkg: () => null
                },
                '../backend': {
                    bundle: function (_, resp) {

                        expect(resp.dependencies.length).to.be.above(250);
                        expect(resp.bundle_signature.length).to.equal(40);
                        delete process.env.SQREEN_TOKEN;

                        done();
                    }
                }
            });

            MockedAction.get_bundle(null, 10);

        });
    });

    describe('actions_reload', () => {

        it('should fail to reload actions', { plan: 1 }, (done) => {

            require('../../../lib/agent').setSESSION_ID(undefined);
            Action.actions_reload('', '').catch((x) => {

                expect(x).to.exist();
                done();
            });
        });

        it('should reload actions', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    actionspack: function () {

                        return Promise.resolve({ actions: [] });
                    }
                }
            });
            MockedAction.actions_reload('', '')
                .then((x) => {

                    expect(x).to.equal({});
                    done();
                });
        });

        it('should reload actions with a bad kid', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    actionspack: function () {

                        return Promise.resolve({
                            actions: [
                                { action: '42', action_id: 1 }
                            ]
                        });
                    }
                }
            });
            MockedAction.actions_reload('', '')
                .then((x) => {

                    expect(x).to.equal({ unsupported_actions: [1] });
                    done();
                });
        });
    });

    describe('performance_budget', () => {

        it('should update current budget value', { plan: 4 }, (done) => {

            const Budget = require('../../../lib/instrumentation/budget.js');
            expect(Budget.getBudget()._isInfinity).to.be.true();

            Action.performance_budget([1000], 'uuid');

            expect((Budget.getBudget().remain)).to.equal(1000);

            Action.performance_budget([], 'uuid');
            Action.performance_budget([null], 'uuid');

            expect(Budget.getBudget()._isInfinity).to.be.true();

            const metric = require('../../../lib/metric').getMetric({ name: 'request_overbudget_cb' });
            expect(metric).to.exist();
            Budget.setBudget(Infinity);
            done();
        });

        it('should not update current budget value', { plan: 3 }, (done) => {

            const Budget = require('../../../lib/instrumentation/budget.js');
            expect(Budget.getBudget(false)._isInfinity).to.be.true();

            Action.performance_budget(['hello'], 'uuid')
                .catch((e) => {

                    expect(e).to.exist();
                    expect(Budget.getBudget(true)._isInfinity).to.be.true();
                    done();
                });
        });
    });

    describe('report_routing_table', () => {

        it('should test failure cases', { plan: 1 }, (done) => {

            const Ccommand = Proxyquire('../../../lib/command/actions', {
                '../../lib_old/instrumentation/record': {
                    collectTable(cb) {

                        return cb(new Error('fail!'));
                    }
                },
                '../instrumentation/record': {
                    collectTable(cb) {

                        return cb(new Error('fail!'));
                    }
                }
            });
            Ccommand.report_routing_table([], '123' )
                .catch((e) => {

                    expect(e).to.exist();
                    done();
                });
        });
    });


    const reveal = function () {

        describe('reveal_reload', () => {

            it('should test reveal_reload cases', { plan: 1 }, (done) => {

                Shimmer.wrap(require('../../../lib/fuzzer'), 'reload', () => {

                    const fct = function () {

                        fct.__unwrap();
                        return Promise.reject(new Error('Runtime reload failed...'));
                    };
                    return fct;
                });

                Command.reveal_reload()
                    .catch((e) => {

                        expect(e).to.exist();
                        done();
                    });
            });

            it('should test when node is < 6.0.0', { plan: 1 }, (done) => {

                Shimmer.wrap(require('../../../lib/fuzzer'), 'reload', () => {

                    const fct = function () {

                        fct.__unwrap();
                        return Promise.reject(new Error('Runtime reload failed...'));
                    };
                    return fct;
                });

                Shimmer.wrap(require('../../../lib/fuzzer'), 'hasFuzzer', () => {

                    const fct = function () {

                        fct.__unwrap();
                        return false;
                    };
                    return fct;
                });

                Command.reveal_reload()
                    .catch((e) => {

                        expect(e.message).to.equal('Reveal is only supported for Node.js >= 6.0.0');
                        done();
                    });
            });
        });

        describe('reveal_start', () => {

            it('should test reveal_start cases', { plan: 1 }, (done) => {

                Shimmer.wrap(require('../../../lib/fuzzer'), 'start', () => {

                    const fct = function () {

                        fct.__unwrap();
                        return Promise.reject(new Error('Reveal failed to start...'));
                    };
                    return fct;
                });

                Command.reveal_start(['session_2b7e721fa1093245e8400945141e5574'], 'uuid')
                    .catch((e) => {

                        expect(e).to.exist();
                        done();
                    });
            });
        });

        describe('reveal_stop', () => {

            it('should test reveal_stop cases', { plan: 1 }, (done) => {

                Shimmer.wrap(require('../../../lib/fuzzer'), 'stop', () => {

                    const fct = function () {

                        fct.__unwrap();
                        return Promise.reject(new Error('Reveal failed to stop...'));
                    };
                    return fct;
                });

                Command.reveal_stop()
                    .catch((e) => {

                        expect(e).to.exist();
                        done();
                    });
            });
        });
    };

    const Semver = require('semver');
    if (Semver.satisfies(process.version, '>= 6.0.0')) {
        describe('Reveal', reveal);
    }
});
