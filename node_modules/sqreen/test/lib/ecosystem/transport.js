/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Ecosystem = require('../../../lib/ecosystem/index');
const transportInterface = Ecosystem.getInterface('transport');
const Whitelist = require('../../../lib/instrumentation/whitelist');

describe('Ecosystem', () => {

    describe('transportInterface', () => {

        describe('ipAndPath', () => {

            it('should whitelist a pth', { plan: 2 }, (done) => {

                Whitelist.whitelistTheseIPs([]);
                Whitelist.whitelistThesePaths(['/aa']);
                const req = { url: '/aa' };
                const res = transportInterface.ipAndPath.checkIPandPath('155.65.8.35', req, {});
                expect(req._sqreen_ip_whitelist).to.be.true();
                expect(res).to.equal(transportInterface.ipAndPath.ACTIONS.NONE);
                done();
            });

            it('should whitelist an IP range', { plan: 2 }, (done) => {

                Whitelist.whitelistTheseIPs(['155.65.8.3']);
                const req = { url: '/' };
                const res = transportInterface.ipAndPath.checkIPandPath('155.65.8.3', req, {});
                expect(req._sqreen_ip_whitelist).to.be.true();
                expect(res).to.equal(transportInterface.ipAndPath.ACTIONS.NONE);
                done();
            });

            it('should whitelist an IP range but not report metric (coverage test)', { plan: 2 }, (done) => {

                const fo = require('../../../lib/command/features').featureHolder.whitelisted_metric;
                require('../../../lib/command/features').featureHolder.whitelisted_metric = false;
                Whitelist.whitelistTheseIPs(['155.65.8.3']);
                const req = { url: '/' };
                const res = transportInterface.ipAndPath.checkIPandPath('155.65.8.3', req, {});
                expect(req._sqreen_ip_whitelist).to.be.true();
                expect(res).to.equal(transportInterface.ipAndPath.ACTIONS.NONE);
                require('../../../lib/command/features').featureHolder.whitelisted_metric = fo;
                done();
            });

            it('should tell that an IP is blacklisted', { plan: 2 }, (done) => {

                const Action = require('../../../lib/actions');
                const shouldLetThisGo = Action.shouldLetThisGo;

                Action.shouldLetThisGo = () => false;
                const req = { url: 'ddd' };
                const res = transportInterface.ipAndPath.checkIPandPath('155.65.8.8', req, {});
                expect(req._sqreen_ip_whitelist).to.not.exist();
                expect(res).to.equal(transportInterface.ipAndPath.ACTIONS.PREVENT);

                Action.shouldLetThisGo = shouldLetThisGo;
                done();
            });
        });

        describe('getHttpTrace', () => {

            it('should refuse invalid references', { plan: 2 }, (done) => {

                try {
                    transportInterface.getHttpTrace();
                }
                catch (e) {
                    expect(e).to.exist();
                }
                try {
                    transportInterface.getHttpTrace(null);
                }
                catch (e) {
                    expect(e).to.exist();
                }
                done();
            });

            it('should return a request record', { plan: 1 }, (done) => {

                expect(transportInterface.getHttpTrace({}, '')).to.exist();
                done();
            });

            it('should not stop the same transaction twice', { plan: 1 }, (done) => {

                const r = {};
                transportInterface.stopIncomingTransaction(r, () => {

                    expect(1).to.equal(1); // check path is running
                });

                transportInterface.stopIncomingTransaction(r, () => {

                    done(new Error('should not have been called'));
                });
                done();
            });
        });

        describe('getSession', () => {

            it('should return the current session', { plan: 1 }, (done) => {

                const session = transportInterface.getSession();
                session.run(() => {

                    session.set('a', 10);
                    process.nextTick(() => {

                        expect(session.get('a')).to.equal(10);
                        done();
                    });
                });
            });
        });

        describe('stopHttpTransaction', () => {

            it('should cover the method', { plan: 1 }, (done) => {

                const record = {
                    isLegacyRecord: true,
                    close: () => {

                        expect(1).to.equal(1);
                        done();
                    }
                };
                transportInterface.stopHttpTransaction('', '', record);
            });

            it('should fail to close a record', { plan: 1 }, (done) => {

                const report = require('../../../lib/exception').report;
                require('../../../lib/exception').report = function (e) {

                    expect(e.message).to.equal('foo');
                    require('../../../lib/exception').report = report;
                    done();
                    return Promise.resolve();
                };
                const record = {
                    isLegacyRecord: true,
                    close: () => {

                        throw new Error('foo');
                    }
                };
                transportInterface.stopHttpTransaction('', '', record);
            });

            it('should fail to close a new record', { plan: 1 }, (done) => {

                const report = require('../../../lib/exception').report;
                require('../../../lib/exception').report = function (e) {

                    expect(e.message).to.equal('foo');
                    require('../../../lib/exception').report = report;
                    done();
                    return Promise.resolve();
                };
                const record = {
                    close: () => {

                        throw new Error('foo');
                    }
                };
                transportInterface.stopHttpTransaction('', '', record);
            });

        });
    });
});
