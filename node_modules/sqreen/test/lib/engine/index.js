/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const beforeEach = lab.beforeEach;
const it = lab.it;
const expect = Code.expect;

const Engine = require('../../../lib/engine');

describe('Reactive engine', () => {

    beforeEach((done) => {

        Engine.removeAllSubscriptions();
        done();
    });

    it('should test globally the engine', { plan: 3 }, (done) => {

        Engine.subscribe(['foo'], (params) => {

            expect(params.foo).to.equal('bar'); // version will be there but it should not care
        });

        Engine.subscribe(['agent_version', 'foo'], (params) => {

            expect(params).to.equal({
                agent_version: require('../../../version.json').version,
                foo: 'bar'
            });
        });

        Engine.subscribe(['agent_version', 'foo'], (params) => {

            expect(params).to.equal({
                agent_version: require('../../../version.json').version,
                foo: 'bar'
            });
        });

        const newSpan = Engine.createSpanFromRoot();
        newSpan
            .setValue('foo', 'boo')
            .setValue('foo', 'bar')
            .dispatch();
        done();
    });

    it('should run spec test', { plan: 1 }, (done) => {

        const span1 = Engine.createSpanFromRoot();
        span1.setValue('http.req', { method: 'GET' })
            .dispatch();

        Engine.subscribe(['http.req'], (param) => {

            expect(param).to.equal({
                'http.req': { method: 'POST' }
            });
            done();
        });

        span1
            .createChild()
            .setValue('http.req', { method: 'POST' })
            .dispatch();
    });

    it('should check un-subscription paths', { plan: 1 }, (done) => {

        const cb = (param) => {

            expect(param).to.equal({
                'foo': 'bar'
            });
        };
        Engine.subscribe(['foo'], cb);

        Engine.createSpanFromRoot()
            .setValue('foo', 'bar')
            .dispatch();

        Engine.unSubScribe([{ fields: ['foo'], callback: cb }]);
        Engine.createSpanFromRoot()
            .setValue('foo', 'bar')
            .dispatch();
        done();
    });

    it('should un-subscribe a cb but not a group', { plan: 3 }, (done) => {

        const cb1 = (param) => expect(param).to.equal({ 'foo': 'bar' });
        const cb2 = (param) => expect(param).to.equal({ 'foo': 'bar' });
        Engine.subscribe(['foo'], cb1);
        Engine.subscribe(['foo'], cb2);
        Engine.createSpanFromRoot()
            .setValue('foo', 'bar')
            .dispatch();
        Engine.unSubScribe([{ fields: ['foo'], callback: cb1 }]);
        Engine.createSpanFromRoot()
            .setValue('foo', 'bar')
            .dispatch();
        done();
    });

    it('should un-subscribe a cb but not a group', { plan: 3 }, (done) => {

        const cb1 = (param) => expect(param).to.equal({ foo: 1, bar: 2 });
        const cb2 = (param) => expect(param).to.equal({ foo: 1, bar: 2 });
        const cb3 = () => done(new Error('should never have been called'));
        Engine.subscribe(['foo', 'bar'], cb1);
        Engine.subscribe(['foo', 'bar'], cb2);
        Engine.subscribe(['foo', 'bar', 'baz'], cb3);
        Engine.createSpanFromRoot()
            .setMultipleValues({ foo: 1, bar: 2 })
            .dispatch();
        Engine.unSubScribe([{ fields: ['foo', 'bar'], callback: cb1 }]);
        Engine.unSubScribe([{ fields: [], callback: cb1 }]);
        Engine.createSpanFromRoot()
            .setValue('foo', 1)
            .setValue('bar', 2)
            .setValue('hello', 'world')
            .dispatch();
        done();
    });

    it('should make a span not resolve', { plan: 1 }, (done) => {

        const res = Engine.createSpanFromRoot().resolve('hello');
        expect(res).to.not.exist();
        done();
    });

    it('should keep the list clean', { plan: 4 }, (done) => {

        expect(Array.from(Engine.getNeededFieldSet()).sort()).to.equal([]);
        const cb1 = () => {};
        const cb2 = () => {};
        Engine.subscribe(['foo', 'bar'], cb1);
        Engine.subscribe(['foo', 'bar', 'baz'], cb2);
        expect(Array.from(Engine.getNeededFieldSet()).sort()).to.equal(['bar', 'baz', 'foo']);
        Engine.unSubScribe([{ fields: ['foo', 'baz', 'bar'], callback: cb2 }]);
        expect(Array.from(Engine.getNeededFieldSet()).sort()).to.equal(['bar', 'foo']);
        Engine.unSubScribe([{ fields: ['foo', 'bar'], callback: cb1 }]);
        expect(Array.from(Engine.getNeededFieldSet()).sort()).to.equal([]);
        done();
    });
});
