/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Semver = require('semver');

const MockServer = function (onRequest) {

    return {
        emit: function (name, req, res) {

            if (name === 'request') {
                if (onRequest) {
                    onRequest(req);
                }
                // say nothing, do nothing, be nothing
                process.nextTick(() => {

                    res.setHeader('Via', '1.1 mockserver');
                    res.writeHead(202, { 'Content-Type': 'text/plain' });
                    res.write('test');
                    res.write(undefined, undefined, () => {
                    });
                    res.end('end', undefined, () => {
                    });
                    // should do nothing...
                    res.write('useless');
                    res.end();
                });
            }
        }
    };
};

const MockSessionID = 'session_2b7e721fa1093245e8400945141e5574';

const MockRuntime = `
    let self = {};
    exports.V1 = {
        validateEnv: (env) => {
            return env;
        },
        validateRun: (run) => {
            return run;
        },
        initFuzzer: (env, run) => {
            if (!run || !run.corpus || !Array.isArray(run.corpus.requests) || run.corpus.requests.length === 0) {
                return null;
            }
            self._stats = { fuzzer: {} };
            self._fuzzed = 0
            self._done = false;
            return 1;
        },
        getSessionID: (id) => {
            return '${MockSessionID}';
        },
        getRunID: (id) => {
            return 'a-run-id';
        },
        getRunStats: (id) => {
            return {runid: 'a-run-id', stats: self._stats};
        },
        mutateInputRequests: (id, mutations) => {
            if (self._done) {
                return {done: true, value: [
                    {url: '/login/asdl', params: {form: {'hidden': 'secret'}}}
                ]};
            }
            self._done = true;
            return {done: false, value: [
                {url: '/login/23', params: {query: {'returnurl': '/'}}},
                {url: '/login/0x42', params: {query: {'returnurl': '../'}}},
                {url: '/login/sjwej', params: {form: {'hidden': 'secret'}}}
            ]};

        },
        initRequest: (id, request) => {
            return 2;
        },
        finalizeRequest: (id, rid, request, result) => {
            const stats = !self._fuzzed ? {runid: 'a-run-id', stats: self._stats} : undefined;
            const unique = (self._fuzzed % 3) === 0;
            self._fuzzed++;
            return {
                success: true,
                unique,
                updated: {endpoint: '/login/:id', headers: result.headers, statuscode: result.statuscode},
                stats,
                hash: 12345678
            };
        },
        terminateRequest: (id, rid) => {
            return true;
        },
        updateMetrics: (id, records) => {
            const record = records[0];
            if (record.key === 'fuzzer.stopped') {
                self._stats.fuzzer.stopped = '2019-10-11T13:38:02.181Z';
            }
            return true;
        },
        terminateFuzzer: (id) => {
            return true;
        }
    }
`;

const MockBrokenRuntime = `
    exports.V1 = {
        validateEnv: (env) => {
            return env;
        },
        validateRun: (run) => {
            return run;
        },
        initFuzzer: (env, run) => {
            return 1;
        },
        getSessionID: (id) => {
            return '${MockSessionID}';
        },
        getRunID: (id) => {
            return 'a-run-id';
        },
        getRunStats: (id) => {
            return {runid: 'a-run-id', stats: { fuzzer: {} }};
        },
        mutateInputRequests: (id, mutations) => {
            throw new Error('broken');
        },
        updateMetrics: (id, records) => {
            return true;
        },
        terminateFuzzer: (id) => {
            return true;
        }
    }
`;

const MockBrokenRuntimeInterface = {
    code: MockBrokenRuntime,
    status: true,
    version: 1
};

const MockRuntimeInterface = {
    code: MockRuntime,
    status: true,
    version: 1
};

const MockOptions = {
    engine: {
        throughput: {
            batch: 2,
            delay: 100
        },
        timeout: 60000
    },
    mutator: {
        mutations: 200
    }
};

const MockDefaults = {
    method: 'GET',
    endpoint: '/',
    headers: {
        'X-Fuzz': 'Reveal'
    }
};

const MockRunEmpty = {
    options: MockOptions,
    corpus: {
        default: MockDefaults,
        requests: []
    },
    sessionid: MockSessionID,
    status:true
};

const MockRun = {
    options: MockOptions,
    corpus: {
        default: MockDefaults,
        requests: [
            { endpoint: '/login/:username?' },
            { endpoint: '/login' }
        ]
    },
    sessionid: MockSessionID,
    status:true
};

const run = function () {

    const Fuzzer = require('../../../lib/fuzzer/index');
    describe('Fuzzer.main', () => {

        describe('reload', () => {

            it('should handle network failure', { plan: 1 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../backend': {
                        reveal_runtime: function (session) {

                            return Promise.reject(new Error('Connection failure'));
                        }
                    }
                });

                MockedFuzzer.reload()
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should handle bad data', { plan: 1 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../backend': {
                        reveal_runtime: function (session) {

                            return Promise.resolve({ bad: 'data' });
                        }
                    }
                });

                MockedFuzzer.reload()
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should fail on invalid runtime signature', { plan: 2 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../backend': {
                        reveal_runtime: function (session) {

                            return Promise.resolve(MockRuntimeInterface);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            return false;
                        }
                    }
                });

                MockedFuzzer.reload()
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should load valid runtime', { plan: 2 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../backend': {
                        reveal_runtime: function (session) {

                            return Promise.resolve(MockRuntimeInterface);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                        done();
                    });
            });
        });

        describe('start', () => {

            it('should fail when uninitialized', { plan: 1 }, (done) => {

                Fuzzer.start(MockSessionID)
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should handle network failure', { plan: 7 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            expect(session).to.exist();
                            return Promise.resolve(MockRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            expect(session).to.exist();
                            expect(query).to.exist();
                            expect(query.session_id).to.exist();
                            return Promise.reject(new Error('Connection failure'));
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer());

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should handle backend failure while retrieving a run', { plan: 7 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            expect(session).to.exist();
                            return Promise.resolve(MockRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            expect(session).to.exist();
                            expect(query).to.exist();
                            expect(query.session_id).to.exist();
                            return Promise.resolve({ bad: 'run' });
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer());

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .catch((res) => {

                        expect(res).to.exist();
                        done();
                    });
            });

            it('should fail on an empty run', { plan: 7 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            expect(session).to.exist();
                            return Promise.resolve(MockRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            expect(session).to.exist();
                            expect(query).to.exist();
                            expect(query.session_id).to.exist();
                            return Promise.resolve(MockRunEmpty);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer());

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .catch((res) => {

                        expect(res).to.exists();
                        done();
                    });
            });

            it('should fail with a broken runtime', { plan: 9 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    './signals': {
                        recordMutatedRequest: function (request) {

                            return;
                        },
                        recordStats: function (runstats) {

                            expect(runstats).to.exist();
                            expect(runstats.runid).to.equal('a-run-id');
                            if (runstats.stats.fuzzer !== undefined) {
                                done();
                            }
                            return Promise.resolve({});
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            expect(session).to.exist();
                            return Promise.resolve(MockBrokenRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            expect(session).to.exist();
                            expect(query).to.exist();
                            expect(query.session_id).to.exist();
                            return Promise.resolve(MockRun);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer());

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .then((res) => {

                        expect(res).to.equal('a-run-id');
                    });
            });

            it('should start with a valid run', { plan: 29 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    './signals': {
                        recordMutatedRequest: function (request) {

                            expect(request).to.exist();
                            expect(request.endpoint).to.exist();
                            expect(request.headers).to.exists();
                            if (Semver.satisfies(process.version, '>= 7.7.0')) {
                                expect(request.headers.via).to.exists();
                            }
                            else {
                                // we does not expect any headers on old node.js
                                expect(request.headers).to.be.empty();
                            }
                            expect(request.statuscode).to.equal(202);
                        },
                        recordStats: function (runstats) {

                            expect(runstats).to.exist();
                            expect(runstats.runid).to.equal('a-run-id');
                            if (runstats.stats.fuzzer.stopped !== undefined) {
                                done();
                            }
                            return Promise.resolve({});
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            expect(session).to.exist();
                            return Promise.resolve(MockRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            expect(session).to.exist();
                            expect(query).to.exist();
                            expect(query.session_id).to.exist();
                            return Promise.resolve(MockRun);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            expect(runtime).to.exists();
                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer((req) => {

                    expect(Fuzzer.isRequestReplayed(req)).to.be.true();
                    expect(Fuzzer.getSessionID(req)).to.be.equal(MockSessionID);
                }));

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .then((res) => {

                        expect(res).to.equal('a-run-id');
                    });
            });
        });

        describe('stop', () => {

            it('should succeed when uninitialized', { plan: 1 }, (done) => {

                Fuzzer.stop()
                    .then((res) => {

                        expect(res).to.equal(undefined);
                        done();
                    });
            });

            it('should stop a valid run', { plan: 3 }, (done) => {

                const MockedFuzzer = Proxyquire('../../../lib/fuzzer/main', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'id';
                        }
                    },
                    './signals': {
                        recordMutatedRequest: function (request) {

                            return;
                        },
                        recordStats: function (runstats) {

                            return Promise.reject(new Error('Connection failure'));
                        }
                    },
                    '../backend': {
                        reveal_runtime: function (session) {

                            return Promise.resolve(MockRuntimeInterface);
                        },
                        reveal_run: function (session, query) {

                            return Promise.resolve(MockRun);
                        }
                    },
                    './signature': {
                        verifyRuntimeSignature: function (runtime) {

                            // we will test the signature separately
                            return true;
                        }
                    }
                });

                MockedFuzzer.registerServer(MockServer());

                MockedFuzzer.reload()
                    .then((res) => {

                        expect(res).to.equal(1);
                    });

                MockedFuzzer.start(MockSessionID)
                    .then((res) => {

                        expect(res).to.equal('a-run-id');
                    });

                MockedFuzzer.stop()
                    .then((res) => {

                        expect(res).to.equal(undefined);
                        done();
                    });
            });

        });
    });
};

if (require('../../../lib/fuzzer').hasFuzzer()) {
    run();
}

