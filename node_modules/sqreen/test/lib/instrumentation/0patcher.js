/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
// I know this is ugly but this file needs to run before the tests of director

const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;
const patcherPath = '../../../lib/instrumentation/patcher';
const Patcher = require(patcherPath);

const Budget = require('../../../lib/instrumentation/budget');

const INFINITY = Budget.INFINITY;
const ZERO = Budget.ZERO;
const beforeEach = lab.beforeEach;
const afterEach = lab.afterEach;
const SqreenSDK = require('sqreen-sdk');

describe('patcher', () => {

    beforeEach((done) => {

        require('../../../lib/command/features').featureHolder.use_signals = true;
        Budget.ZERO = INFINITY;
        try {
            require('../../../lib/instrumentation/hooks/ns').getNS().set('budget', Budget.INFINITY);
        }
        catch (_) {}
        done();
    });

    afterEach((done) => {

        require('../../../lib/command/features').featureHolder.use_signals = true;
        Budget.ZERO = ZERO;
        Budget.setBudget(Infinity);
        done();
    });

    describe('placePatch', () => {

        it('should not place a patch if the target does not exist', { plan: 6 }, (done) => {

            expect(Patcher.placePatch({ })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'mod' })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'mod', file: './index.js' })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'global', methodName: 'exec' })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'global.dskjghs', methodName: 'exec' })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'global', methodName: 'process' })).to.not.exist();
            done();
        });

        it('should patch a known module and add a callback 1', { plan: 4 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();
            expect(result1.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a'
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a:b'
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'b'
            });
            expect(result1.a.__wrapped).to.be.true();
            expect(result1.a()).to.equal(2);
            done();
        });

        it('should patch a known nested module and add a callback 1', { plan: 4 }, (done) => {

            const module = {
                a: {
                    z: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.z.__wrapped).to.not.exist();
            expect(result1.a.z()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.z',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 20 };
                            }
                        }
                    ]
                }
            });
            expect(result1.a.z.__wrapped).to.be.true();
            expect(result1.a.z()).to.equal(20);
            done();
        });

        it('should patch a known deep nested module and add a callback 1', { plan: 4 }, (done) => {

            const module = {
                a: {
                    k: {
                        z: function () {

                            return 1;
                        }
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.k.z.__wrapped).to.not.exist();
            expect(result1.a.k.z()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.k.z',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 20 };
                            }
                        }
                    ]
                }
            });
            expect(result1.a.k.z.__wrapped).to.be.true();
            expect(result1.a.k.z()).to.equal(20);
            done();
        });

        it('should patch a known module and add a callback and trigger coverage', { plan: 4 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };

            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            module.a.prototype = null;

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();
            expect(result1.a()).to.equal(1);

            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1.a.__wrapped).to.be.true();
            expect(result1.a()).to.equal(2);
            done();
        });

        it('should patch a known module and add an async callback', { plan: 5 }, (done) => {

            const module = {
                a: function (a, b, cb) {

                    return cb(null, a + b);
                }
            };

            Patcher.placePatch({
                moduleName: 'module1',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            module.a.prototype = null;

            const result1 = Patcher.patchModule(module, { name: 'module1', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();

            Patcher.placePatch({
                moduleName: 'module1',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module1',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    asyncPostCbs: [
                        {
                            method: function (args) {

                                expect(args).to.equal([null, 2]);
                                return null;
                            }
                        }
                    ]
                }
            });
            expect(result1.a.__wrapped).to.be.true();
            module.a(1, 1, (err, res) => {

                expect(err).to.not.exist();
                expect(res).to.equal(2);
                done();
            });
        });

        it('should patch a known module and add an async callback that resolve a promise', { plan: 4 }, (done) => {

            const module = {
                a: function (a, b) {

                    return Promise.resolve(a + b);
                }
            };

            Patcher.placePatch({
                moduleName: 'module2',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            module.a.prototype = null;

            const result1 = Patcher.patchModule(module, { name: 'module2', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();

            Patcher.placePatch({
                moduleName: 'module2',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module2',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    asyncPostCbs: [
                        {
                            method: function (args) {

                                expect(args).to.equal([null, 2]);
                                return null;
                            }
                        }
                    ]
                }
            });
            expect(result1.a.__wrapped).to.be.true();
            module.a(1, 1)
                .then((res) => {

                    expect(res).to.equal(2);
                    done();
                });
        });

        it('should patch a known module and add an async callback that reject a promise', { plan: 4 }, (done) => {

            const module = {
                a: function (a, b) {

                    return Promise.reject(a + b);
                }
            };

            Patcher.placePatch({
                moduleName: 'module3',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            module.a.prototype = null;

            const result1 = Patcher.patchModule(module, { name: 'module3', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();

            Patcher.placePatch({
                moduleName: 'module3',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module3',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    asyncPostCbs: [
                        {
                            method: function (args) {

                                expect(args).to.equal([null, 2]);
                                return null;
                            }
                        }
                    ]
                }
            });
            expect(result1.a.__wrapped).to.be.true();
            module.a(1, 1)
                .catch((res) => {

                    expect(res).to.equal(2);
                    done();
                });
        });

        it('should patch a known module and add a callback 2', { plan: 4 }, (done) => {

            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1.s.a.__wrapped).to.be.true();
            expect(result1.s.a()).to.equal(2);
            done();
        });

        it('should patch a known module and add a callback but not run because budget is over', { plan: 4 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(50); // 50ms budget
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const m0 = function () {


                return null;
            };
            m0.noBudget = true;

            const m1 = function () {

                done(new Error('Should not have been called'));

                return { status: 'skip', newReturnValue: 2 };
            };

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'null' },
                            method: m0
                        },
                        {
                            rule: { name: 'return 2' },
                            method: m1
                        }
                    ],
                    failCbs: [
                        {
                            rule: { name: 'null' },
                            method: m0
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                budget.remain = 0;
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(1);
                Budget.setBudget(Infinity);

                done();
            });
        });

        it('should patch a known module and add a callback but not run because rule is not enabled', { plan: 4 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const m0 = function () {


                return null;
            };
            m0.noBudget = true;

            const m1 = function () {

                done(new Error('Should not have been called'));

                return { status: 'skip', newReturnValue: 2 };
            };

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'null', enabled: false },
                            method: m0
                        },
                        {
                            rule: { name: 'return 2', enabled: false },
                            method: m1
                        }
                    ],
                    failCbs: [
                        {
                            rule: { name: 'null', enabled: false },
                            method: m0
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                budget.remain = Infinity;
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(1);
                Budget.setBudget(Infinity);

                done();
            });
        });

        it('should patch a known module and add a callback with a budget', { plan: 5 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(50); // 50ms budget
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2' },
                            method: function () {

                                for (let i = 0; i < 30000; ++i) {}

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(budget.remain).to.be.below(49.9);

                done();
            });
        });

        it('should create a signal out of a callback execution', { plan: 6 }, (done) => {

            const Sampler = require('../../../lib/signals/sampling').Sampler;
            const Record = require('../../../lib/instrumentation/record');
            const req = { __sqreen_uuid: '' };
            const record = Record.lazyGet(req);
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            let i = 0;
            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2', sampler: new Sampler([{ max_calls: 3 }]) },
                            method: function () {

                                ++i;
                                if (i === 2) {
                                    return { observations: [], signals: [{ name: 'sig2', payload: { a: 1 } }] };
                                }
                                if (i === 3) {
                                    return { observations: [], record: {} };
                                }

                                return { signals: [{ name: 'sig', payload: { a: 1 } }] };
                            }
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                NS.set('req', req);
                result1.s.a();
                result1.s.a();
                result1.s.a();
                result1.s.a();
                result1.s.a();
                result1.s.a();
                expect(record.data).to.have.length(3);
                expect(record.data[0].signal_name).to.equal('sig');
                expect(record.data[0].source).to.equal('sqreen:rule:undefined:return 2');
                expect(record.data[0].trigger).to.equal({ max_calls: 3 });
                expect(record.data[1].signal_name).to.equal('sig2');
                expect(record.data[1].trigger).to.equal({ max_calls: 3 });

                done();
            });
        });

        it('should patch a known module and add a callback with a budget and finish it', { plan: 7 }, (done) => {

            SqreenSDK.initBatch(1000, 1000, () => Promise.resolve());
            const Metrics = require('../../../lib/metric/index.js');
            Metrics.getAllReports(true);
            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(0.5);
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2' },
                            method: function () {

                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget(true);
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(budget.remain).to.be.below(0);

                Metrics.getAllReports(true);

                const met = SqreenSDK.Signal.prototype.BATCH.data.find((x) => x.signal_name === 'sq.agent.metric.request_overbudget_cb');
                expect(met).to.exist();
                expect(met.payload.values).to.equal([{ key: 'return 2', value: 1 }]);

                done();
            });
        });

        it('should patch a known module and add a callback with a monitoring budget and finish it', { plan: 10 }, (done) => {

            SqreenSDK.initBatch(1000, 1000, () => Promise.resolve());
            const Metrics = require('../../../lib/metric/index.js');
            Metrics.getAllReports(true);
            require('../../../lib/metric/default').enableRequestOvertime();
            require('../../../lib/metric/default').enableMonitRequestOvertime();

            Budget.setBudget(5);
            Budget.setMonitBudget(0.5);
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2', purpose: 'monitoring' },
                            method: function () {

                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}
                                for (let i = 0; i < 60000; ++i) {}

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget(true);
                const monitBudget = Budget.getMonitoringBudget(true);
                NS.set('budget', budget);
                NS.set('monitBudget', monitBudget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(monitBudget.remain).to.be.below(0);
                expect(budget.remain).to.be.above(0);

                expect(5 - budget.remain).to.be.below(monitBudget.sum);
                expect(5 - budget.remain).to.be.below(monitBudget.sum + 5);

                Metrics.getAllReports(true);

                const met = SqreenSDK.Signal.prototype.BATCH.data.find((x) => x.signal_name.endsWith('monitoring_request_overbudget_cb'));
                expect(met).to.exist();
                expect(met.payload.values).to.equal([{ key: 'return 2', value: 1 }]);

                done();
            });
        });

        it('should patch a known module and add a callback with a nobudget', { plan: 6 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(50); // 50ms budget
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const method = function () {

                for (let i = 0; i < 10; ++i) {}

                return { status: 'skip', newReturnValue: 2 };
            };
            method.noBudget = true;

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2' },
                            method
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(budget.remain).to.be.below(50);
                expect(budget.remain).to.be.above(48);

                done();
            });
        });

        it('should patch a known module and add a callback with a nobudget', { plan: 5 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(50); // 50ms budget
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const method = function () {

                for (let i = 0; i < 10; ++i) {}

                return { status: 'skip', newReturnValue: 2 };
            };
            method.noBudget = true;

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: { name: 'return 2' },
                            method
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                budget.remain = 0;
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(budget.remain).to.be.below(0);

                done();
            });
        });

        it('should patch a known module and add a callback with a nobudget', { plan: 5 }, (done) => {

            require('../../../lib/metric/default').enableRequestOvertime();

            Budget.setBudget(50); // 50ms budget
            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const method = function () {

                for (let i = 0; i < 10; ++i) {}

                return { status: 'skip', newReturnValue: 2 };
            };
            method.noBudget = true;

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    postCbs: [
                        {
                            rule: { name: 'return 2' },
                            method
                        }
                    ]
                }
            });
            const NS = require('../../../lib/instrumentation/hooks/util').getNS();
            NS.run(() => {

                const budget = Budget.getBudget();
                budget.remain = 0;
                NS.set('budget', budget);
                expect(result1.s.a.__wrapped).to.be.true();
                expect(result1.s.a()).to.equal(2);
                Budget.setBudget(Infinity);

                expect(budget.remain).to.be.below(0);

                done();
            });
        });

        it('should patch a known module and add a callback 3', { plan: 4 }, (done) => {

            const module = {
                c: class {

                    constructor() {

                        this.x = 1;
                    }

                    a() {

                        return this.x;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module3' }, 'mod');

            const instance = new result1.c();
            expect(instance.a.__wrapped).to.not.exist();
            expect(instance.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module3',
                methodName: 'c.prototype:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });

            Patcher.placePatch({
                moduleName: 'module3',
                methodName: 'c.prototype:a'
            });
            expect(instance.a.__wrapped).to.be.true();
            expect(instance.a()).to.equal(2);
            done();
        });

        it('should patch a known module without method name and add a callback', { plan: 4 }, (done) => {

            const module = {
                '': function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1[''].__wrapped).to.not.exist();
            expect(result1['']()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1[''].__wrapped).to.be.true();
            expect(result1['']()).to.equal(2);
            done();
        });

        it('should patch a known module and test exception cap', { plan: 3 }, (done) => {

            const module = {
                '': function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module555', relativePath: './index.js' }, 'mod');

            let fail = false;

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            const ExceptionCap = require('../../../lib/rules/exceptions');
            const cap = new ExceptionCap({ name: 'maybeFail-2', rulesPack: '1' });

            const method = function () {

                if (fail) {
                    throw new Error('err');
                }
            };

            method.noBudget = true;

            Director.update({
                moduleName: 'module555',
                file: './index.js',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            rule: {
                                name: 'maybeFail-2',
                                rulesPack: '1',
                                purpose: 'monitoring',
                                exception_cap: cap
                            },
                            method
                        }
                    ]
                }
            });
            expect(result1[''].__wrapped).to.be.true();
            result1['']();
            expect(cap.ema).to.equal(0);
            fail = true;
            result1['']();
            expect(cap.ema).to.equal(0.00106049);
            done();
        });
    });
});
