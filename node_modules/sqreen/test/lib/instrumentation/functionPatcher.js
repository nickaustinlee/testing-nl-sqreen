/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const FunctionPatcher = require('../../../lib/instrumentation/functionPatcher');
const CallbackBuilder = require('../../../lib/rules/rules-callback/callbackBuilder');
const Director = require('../../../lib/instrumentation/sqreenDirector');
const Record = require('../../../lib/instrumentation/record');
const Shimmer = require('shimmer');
const Semver = require('semver');
// TODO: test all functions definitions

const Budget = require('../../../lib/instrumentation/budget');

const INFINITY = Budget.INFINITY;
const ZERO = Budget.ZERO;
const beforeEach = lab.beforeEach;
const afterEach = lab.afterEach;


const fakeGetCbs = (ruleList) => {

    return ruleList.map((entry) => {

        const result = CallbackBuilder.getCbs(Object.assign({}, {
            callbacks: {
                nodejs: {
                    pre: ['function () { throw null }']
                }
            },
            data: {}
        }, entry.rule));
        // Clone .method properties
        Object.keys(result.pre).forEach((k) => (entry.method[k] = result.pre[k]));
        return { method: entry.method, rule: entry.rule };
    });
};

const runReveal = function () {

    it('should catch error and report it to reveal', { plan: 4 }, (done) => {

        const req = {
            __sqreen_uuid: 555,
            __sqreen_replayed: true
        };

        Shimmer.wrap(require('../../../lib/fuzzer'), 'updateRequestMetric', () => {

            const fct = function (r, key, val, met) {

                expect(r).to.equal(req);
                expect(key).to.equal('exceptions.failed_rules');
                expect(val).to.equal(1);
                expect(met).to.equal(2);

                fct.__unwrap();
                done();
            };
            return fct;
        });

        const runCbs = FunctionPatcher._runCbs;
        const list = [
            {
                method() {

                    throw new Error('my error');
                }
            }
        ];
        runCbs(list, null, null, null, null, { req });
    });

    it('should not run a reveal purposed rule with a non-replayed request (only if explicit)', { plan: 5 }, (done) => {

        const req = {
            __sqreen_uuid: 555
        };

        const ruleList = [
            {
                rule: {
                    purpose: 'reveal'
                },
                method: function () {

                    done(new Error('should not have been called'));
                    throw new Error('should not have been called');
                }
            },
            {
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'original'
                            }
                        ]
                    }
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'both'
                            }
                        ]
                    }
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'monitoring'
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'monitoring'
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                    return {
                        data_points: []
                    };
                }
            }
        ];

        const cbList = fakeGetCbs(ruleList);
        const runCbs = FunctionPatcher._runCbs;
        const res = runCbs(cbList, null, null, null, new Budget(10000), { req });

        expect(res).to.equal([
            {},
            {
                session: { req },
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'original'
                            }
                        ]
                    }
                },
                params: { args: null, value: null },
                trigger: null
            },
            {
                session: { req },
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'both'
                            }
                        ]
                    }
                },
                params: { args: null, value: null },
                trigger: null
            },
            {
                session: { req },
                rule: { purpose: 'monitoring' },
                params: { args: null, value: null },
                trigger: null
            },
            {
                data_points: [],
                session: { req },
                rule: { purpose: 'monitoring' },
                params: { args: null, value: null },
                trigger: null
            }
        ]);

        done();
    });

    it('should run a reveal purposed rule with a replayed request', { plan: 5 }, (done) => {

        const req = {
            __sqreen_uuid: 555,
            __sqreen_replayed: true
        };

        const ruleList = [
            {
                rule: {
                    purpose: 'reveal'
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'fuzzed'
                            }
                        ]
                    }
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'both'
                            }
                        ]
                    }
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    expect(timeout).to.equal(Infinity);
                }
            },
            {
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'original'
                            }
                        ]
                    }
                },
                method: function (args, value, rule, selfObject, session, timeout) {

                    done(new Error('should not have been called'));
                    throw new Error('should not have been called');
                }
            }

        ];
        Shimmer.wrap(require('../../../lib/fuzzer'), 'recordStackTrace', () => {

            const fct = function (r) {

                expect(r).to.equal(req);
                fct.__unwrap();
            };
            return fct;
        });

        const cbList = fakeGetCbs(ruleList);
        const runCbs = FunctionPatcher._runCbs;
        const res = runCbs(cbList, null, null, null, new Budget(10000), { req });

        expect(res).to.equal([
            {
                session: { req },
                rule: { purpose: 'reveal' },
                params: { args: null, value: null },
                trigger: null
            },
            {
                session: { req },
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'fuzzed'
                            }
                        ]
                    }
                },
                params: { args: null, value: null },
                trigger: null
            },
            {
                session: { req },
                rule: {
                    purpose: 'reveal',
                    data: {
                        values: [
                            {
                                no_budget: true,
                                reveal_run_on: 'both'
                            }
                        ]
                    }
                },
                params: { args: null, value: null },
                trigger: null
            },
            {}
        ]);

        done();
    });
};


describe('functionPatcher', () => {

    beforeEach((done) => {

        Budget.ZERO = INFINITY;
        done();
    });

    afterEach((done) => {

        Budget.ZERO = ZERO;
        done();
    });

    describe('_runCbs', () => {

        // reveal only tests
        if (Semver.satisfies(process.version, '>= 6.0.0')) {
            describe('Reveal', runReveal);
        }

        it('should catch error to record', { plan: 2 }, (done) => {

            require('../../../lib/command/features').featureHolder.use_signals = false;
            const req = {
                __sqreen_uuid: 555
            };
            const OldRecord = require('../../../lib_old/instrumentation/record');
            const record = new OldRecord.Record(req);

            record.except = function (error) {

                expect(error.klass).to.equal(Error.name);
                expect(error.message).to.equal('my error');

                OldRecord.STORE.delete(555);
                require('../../../lib/command/features').featureHolder.use_signals = true;
                done();
            };

            const runCbs = FunctionPatcher._runCbs;
            const list = [
                {
                    method() {

                        throw new Error('my error');
                    }
                }
            ];
            runCbs(list, null, null, null, null, { req });
        });

        it('should catch error to record new', { plan: 2 }, (done) => {

            const req = {
                __sqreen_uuid: 555
            };
            const record = new Record.RecordTrace(req);

            record.except = function (k, m) {

                expect(k).to.equal(Error.name);
                expect(m).to.equal('my error');

                Record.STORE.delete(555);
                done();
            };

            const runCbs = FunctionPatcher._runCbs;
            const list = [
                {
                    method() {

                        throw new Error('my error');
                    },
                    rule: { name: 'xxx' }
                }
            ];
            runCbs(list, null, null, null, null, { req });
        });

        it('should not catch error to record', { plan: 0 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            const list = [
                {
                    method() {

                        throw new Error('my error');
                    }
                }
            ];
            runCbs(list, null, null, null, null, { req: null });
            done();
        });

        it('should not catch error to record', { plan: 0 }, (done) => {

            const req = {
            };

            const runCbs = FunctionPatcher._runCbs;
            const list = [
                {
                    method() {

                        throw new Error('my error');
                    }
                }
            ];
            runCbs(list, null, null, null, null, { req });
            done();
        });


        it('should not run the cb because of whitelist', { plan: 1 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            const result = runCbs([{
                method: function () {

                    return done(new Error('should not have ran'));
                }
            }], null, null, null, '', { req: { _sqreen_ip_whitelist: true } });

            expect(result).to.equal([]);
            done();
        });

        it('should collect the result of the pre with a passed context', { plan: 1 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            const result = runCbs([{
                method: function () {

                    return { x: 'x' };
                }
            }], null, null, null, '', { req: { } });

            expect(result[0].x).to.equal('x');
            done();

        });

        it('should collect the result of the pre', { plan: 2 }, (done) => {

            const MockeFctP = Proxyquire('../../../lib/instrumentation/patch', {
                '../command/features': {
                    read: function () {

                        return { call_counts_metrics_period: 10 };
                    }
                },
                '../metric': {
                    addObservations: function () {}
                }
            });
            const runCbs = MockeFctP._runCbs;
            const result = runCbs([{
                method: function () {

                    return { x: 'x' };
                }
            }]);

            const result2 = runCbs([{
                method: function () {

                    return { x: 'x' };
                },
                rule: {}
            }]);

            expect(result[0].x).to.equal('x');
            expect(result2[0].x).to.equal('x');
            done();

        });

        it('should collect the result of the pre with a context', { plan: 1 }, (done) => {

            require('../../../vendor/continuation-local-storage/context').createNamespace('sqreen_session');
            const runCbs = FunctionPatcher._runCbs;
            const result = runCbs([{
                method: function () {

                    return { x: 'x' };
                }
            }]);

            expect(result[0].x).to.equal('x');
            require('../../../vendor/continuation-local-storage/context').destroyNamespace('sqreen_session');
            done();

        });

        it('should guarantee exlusion on runCbs', { plan: 0 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            process.__sqreen_cb = true;
            runCbs([{ method: function () {

                done(new Error('should not have run'));
            } }]);

            delete process.__sqreen_cb;
            done();
        });

        it('should catch errors in cbs', { plan: 1 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            runCbs([{ method: function () {

                throw new Error('should have run');
            } }]);

            expect(process.__sqreen_cb).to.be.false();
            done();
        });

        it('should catch errors in cbs', { plan: 1 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            runCbs([{ method: function () {

                throw 'should have run';
            } }]);

            expect(process.__sqreen_cb).to.be.false();
            done();
        });

        it('should catch errors in cbs with a rule', { plan: 1 }, (done) => {

            const runCbs = FunctionPatcher._runCbs;
            runCbs([
                {
                    method: function () {

                        throw new Error('should have run');
                    },
                    rule: {}
                }
            ]);

            expect(process.__sqreen_cb).to.be.false();
            done();
        });
    });

    describe('patchFunction', () => {

        it('should register a function in director', { plan: 8 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module0', version: '1.0.0', relativePath: 'lib/index.js' });

            const instrumentation = Director._getInstrumented();

            expect(instrumentation.module0).to.exist();
            expect(instrumentation.module0['1.0.0']).to.exist();
            expect(instrumentation.module0['1.0.0']['lib/index.js']).to.exist();
            expect(instrumentation.module0['1.0.0']['lib/index.js'].a).to.exist();
            expect(instrumentation.module0['1.0.0']['lib/index.js'].a).to.be.an.array();
            expect(instrumentation.module0['1.0.0']['lib/index.js'].a).to.have.length(1);
            expect(instrumentation.module0['1.0.0']['lib/index.js'].a[0]).to.be.a.function();
            expect(module.a.__wrapped).to.be.true();

            done();
        });

        it('update a function', { plan: 8 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.a = 1;
            const module = {
                a: fct
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'holder:a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: () => {},
                params: {
                    preCbs: [{ method: function (args) {

                        expect(args['0']).to.be.a.number();
                    } }],
                    postCbs: [{ method: function (args, value) {

                        expect(value).to.equal(1);
                    } }]
                }
            });

            const wrapped = module.a;

            const value = wrapped(0);
            expect(value).to.equal(fct(0));
            expect(wrapped.a).to.equal(fct.a);
            expect(wrapped.__proto__).to.equal(fct.__proto__);
            expect(wrapped.length).to.equal(fct.length);
            expect(wrapped.name).to.equal(fct.name);

            done();
        });

        it('update an arrow function', { plan: 7 }, (done) => {

            const fct = (x) => x + 1;
            fct.a = 1;
            const module = {
                a: fct
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'holder:a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: () => {},
                params: {
                    preCbs: [{ method: function (args) {

                        expect(args['0']).to.be.a.number();
                    } }],
                    postCbs: [{ method: function (args, value) {

                        expect(value).to.equal(1);
                    } }]
                }
            });

            const wrapped = module.a;

            const value = wrapped(0);

            expect(value).to.equal(fct(0));
            expect(wrapped.a).to.equal(fct.a);
            expect(wrapped.length).to.equal(fct.length);
            expect(wrapped.name).to.equal(fct.name);
            done();
        });

        it('patch a constructor', { plan: 2 }, (done) => {

            const fct = function X() {

                this.a = this.a + 1 || 0;
            };

            const holder = { fct };
            FunctionPatcher.patchFunction(holder, 'fct', { name: 'a' });

            const item = new holder.fct();
            expect(item.a).to.equal(0);
            holder.fct.apply(item);
            expect(item.a).to.equal(1);
            done();
        });

        it('update a class', { plan: 14 }, (done) => {

            const fct = class {

                constructor(x) {

                    this.x = x;
                }
            };
            const ext = class extends fct {
                constructor(x) {

                    super(x);
                }
            };

            const Fs = require('fs');

            const fs$WriteStream = Fs.WriteStream;


            const c = function WriteStream(path, options) {  // eslint-disable-line

                if (this instanceof WriteStream){
                    return fs$WriteStream.apply(this, arguments), this;  // eslint-disable-line
                }
            };
            c.prototype = Object.create(fs$WriteStream.prototype);

            const d = function WriteStream2(path, options) {  // eslint-disable-line

                return fs$WriteStream.apply(this, arguments), this;  // eslint-disable-line
            };

            const module = {
                a: fct,
                b: ext,
                c, d
            };
            FunctionPatcher.patchFunction(module, '__unwrap', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');
            FunctionPatcher.patchFunction(module, '__original', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');
            FunctionPatcher.patchFunction(module, 'c', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');
            FunctionPatcher.patchFunction(module, 'd', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'holder');

            expect(new module.a(1).x).to.equal(new fct(1).x);

            Director.update({
                moduleName: 'module1',
                methodName: 'holder:a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: () => {},
                params: {
                    preCbs: [{ method: function (args) {

                        expect(args['0']).to.be.a.number();
                    } }],
                    postCbs: [{ method: function (args, value) {

                        expect(value).to.equal(1);
                    } }]
                }
            });

            const wrapped = module.a;

            expect(new wrapped(0).x).to.equal(new fct(0).x);
            expect(new wrapped(0)).to.be.an.instanceof(fct);
            expect(new ext(0)).to.be.an.instanceof(fct);
            expect(new ext(0)).to.be.an.instanceof(ext);
            expect((new module.c('./aaa.logs'))._writableState).to.exist();

            const tmpObj = {};
            Object.setPrototypeOf(tmpObj, null);
            expect(module.d.apply(tmpObj, ['./aa.logs'])).to.exist();
            expect(wrapped.__proto__).to.equal(fct.__proto__);
            expect(wrapped.length).to.equal(fct.length);
            expect(wrapped.name).to.equal(fct.name);

            done();
        });

        it('update a function and hijack its return value at pre', { plan: 4 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: () => {},
                params: {
                    preCbs: [
                        { method: function () {

                            return { status: 'skip', newReturnValue: '5' };
                        } }]
                }
            });

            const wrapped = module.a;

            process.__sqreen_cb = true;
            expect(wrapped(0)).to.equal(1);
            process.__sqreen_cb = false;

            expect(wrapped(0)).to.equal('5');
            expect(wrapped.prototype.fct(0)).to.equal(1);
            done();
        });

        it('update a function and not hijack its return value at pre because of pre-condition)', { plan: 4 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: '5' };
                            },
                            rule: {
                                conditions: {
                                    pre: {
                                        '%and': ['0', '0']
                                    }
                                }
                            }
                        }]
                }
            });

            const wrapped = module.a;

            process.__sqreen_cb = true;
            expect(wrapped(0)).to.equal(1);
            process.__sqreen_cb = false;

            expect(wrapped(0)).to.equal(1);
            expect(wrapped.prototype.fct(0)).to.equal(1);
            done();
        });

        it('update a function and raise its return value at pre', { plan: 2 }, (done) => {

            const session = require('../../../vendor/continuation-local-storage/context').createNamespace('sqreen_session');

            session.run(() => {

                session.set('req', {
                    socket: {
                        end: function () {}
                    }
                });
                session.set('res', {
                    writeHead: function () {},
                    end: function () {}
                });

                const fct = function (x) {

                    return x + 1;
                };
                fct.prototype = {
                    fct
                };
                const module = {
                    a: fct // ensure that infinte recusrions are not happenning
                };
                const MockedFunctionPatcher = Proxyquire('../../../lib/instrumentation/functionPatcher', {
                    '../constructors/attack': function (){}
                });
                MockedFunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

                expect(module.a(1)).to.equal(fct(1));

                Director.update({
                    moduleName: 'module1',
                    methodName: 'a',
                    file: 'lib/index.js',
                    versions: '1.0.0',
                    build: () => {},
                    params: {
                        preCbs: [
                            {
                                method: function () {

                                    return {
                                        status: 'raise',
                                        record: {},
                                        originalSession: {
                                            req: {
                                                socket: {
                                                    end: function () {}
                                                }
                                            },
                                            res: {
                                                writeHead: function () {},
                                                end: function () {}
                                            }
                                        }
                                    };
                                }
                            }
                        ]
                    }
                });

                const wrapped = module.a;

                const res = wrapped(0);
                expect(res).to.not.exist();
                require('../../../vendor/continuation-local-storage/context').destroyNamespace('sqreen_session');
                done();
            });
        });

        it('update a function and raise its return value at pre with observation', { plan: 4, timeout: 4000 }, (done) => {

            const session = require('../../../vendor/continuation-local-storage/context').createNamespace('sqreen_session');

            session.run(() => {

                session.set('req', {
                    socket: {
                        end: function () {}
                    }
                });
                session.set('res', {
                    writeHead: function () {},
                    end: function () {}
                });

                const fct = function (x) {

                    return x + 1;
                };
                fct.prototype = {
                    fct
                };
                const module = {
                    a: fct // ensure that infinte recusrions are not happenning
                };
                const MockedFunctionPatcher = Proxyquire('../../../lib/instrumentation/functionPatcher', {
                    '../constructors/attack': function (){}
                });
                MockedFunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

                expect(module.a(1)).to.equal(fct(1));

                Director.update({
                    moduleName: 'module1',
                    methodName: 'a',
                    file: 'lib/index.js',
                    versions: '1.0.0',
                    build: () => {},
                    params: {
                        preCbs: [
                            {
                                method: function () {

                                    return { observations: [] };
                                }
                            },
                            {
                                method: function () {

                                    return { status: 'raise', observations: [['a', 'b', 1]] };
                                },
                                rule: {
                                    name: 'rule',
                                    metrics: [{
                                        name: 'a',
                                        kind: 'Sum',
                                        period: 1
                                    }]
                                }
                            }
                        ]
                    }
                });

                require('../../../lib/metric').getMetric({
                    name: 'a',
                    kind: 'Sum',
                    period: 2
                });

                require('../../../lib/metric').getMetric({
                    name: 'a',
                    kind: 'Sum',
                    period: 1
                });

                require('../../../lib/metric').getMetric({
                    name: 'http_code',
                    kind: 'Sum',
                    period: 1
                });

                const wrapped = module.a;

                const res = wrapped(0);
                expect(res).to.not.exist();
                require('../../../vendor/continuation-local-storage/context').destroyNamespace('sqreen_session');

                setTimeout(() => {

                    setImmediate(() => {

                        const metric = require('../../../lib/metric').getMetricByName('a');
                        expect(metric.kind).to.equal('sum');
                        expect(metric.getSignal(new Date()).payload.values).to.equal([{ key: 'b', value: 1 }]);
                        done();
                    });
                }, 2000);
            });
        });

        it('update a function and raise its return value at pre with observation', { plan: 3, timeout: 4000 }, (done) => {

            require('../../../lib/metric').getAllReports(true);
            const session = require('../../../vendor/continuation-local-storage/context').createNamespace('sqreen_session');

            session.run(() => {

                session.set('req', {
                    socket: {
                        end: function () {}
                    },
                    __sqreen_uuid: 'dasuygashjgdas'
                });
                session.set('res', {
                    writeHead: function () {},
                    end: function () {}
                });

                const fct = function (x) {

                    return x + 1;
                };
                fct.prototype = {
                    fct
                };
                const module = {
                    a: fct // ensure that infinte recusrions are not happenning
                };
                const MockedFunctionPatcher = Proxyquire('../../../lib/instrumentation/functionPatcher', {
                    '../constructors/attack': function (){}
                });
                MockedFunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

                expect(module.a(1)).to.equal(fct(1));

                Director.update({
                    moduleName: 'module1',
                    methodName: 'a',
                    file: 'lib/index.js',
                    versions: '1.0.0',
                    build: function () {

                        this.params = {
                            preCbs: [
                                {
                                    method: function () {

                                        return { observations: [] };
                                    }
                                },
                                {
                                    method: function () {

                                        return { status: 'raise', observations: [['a', 'b', 1]] };
                                    },
                                    rule: {
                                        name: 'rule',
                                        metrics: [{
                                            name: 'a',
                                            kind: 'Sum',
                                            period: 1
                                        }]
                                    }
                                }
                            ]
                        };
                    },
                    params: []
                });

                require('../../../lib/metric').getMetric({
                    name: 'a',
                    kind: 'Sum',
                    period: 2
                });

                require('../../../lib/metric').getMetric({
                    name: 'a',
                    kind: 'Sum',
                    period: 1
                });

                const wrapped = module.a;

                const res = wrapped(0);
                expect(res).to.not.exist();
                require('../../../vendor/continuation-local-storage/context').destroyNamespace('sqreen_session');

                setTimeout(() => {

                    setImmediate(() => {

                        const metric = require('../../../lib/metric').getMetricByName('a');
                        expect(metric.getSignal().payload.values).to.equal([{ key: 'b', value: 1 }]);
                        done();
                    });
                }, 2000);
            });
        });

        it('update a function and hijack its return value at fail', { plan: 1 }, (done) => {

            const fct = function () {

                throw new Error();
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function () {

                            return { status: 'skip', newReturnValue: '5' };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            expect(wrapped(0)).to.equal('5');
            done();
        });


        it('update a function and do nothing to its return value at fail', { plan: 1 }, (done) => {

            const fct = function () {

                throw new Error();
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function () {

                            return { };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            try {
                wrapped(0);
            }
            catch (err) {
                expect(err).to.exist();
            }
            done();
        });

        it('update a function and hijack its return value at fail', { plan: 1 }, (done) => {

            const fct = function () {

                throw new Error();
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function () {

                            return { status: 'raise', newReturnValue: '5' };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            try {
                expect(wrapped(0)).to.equal('5');
            }
            catch (err) {
                return done(err);
            }
            done();
        });

        it('update a function and raise its return value at fail 2', { plan: 1 }, (done) => {

            const fct = function () {

                throw new Error();
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function () {

                            return { status: 'raise', stauts: 'nothing' };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            try {
                expect(wrapped(0)).to.not.exist();
                done();
            }
            catch (err) {
                done(err);
            }
        });

        it('update a function and raise its return value at fail with session', { plan: 1 }, (done) => {

            const fct = function () {

                throw new Error();
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function () {

                            return {
                                status: 'raise',
                                stauts: 'nothing',
                                newReturnValue: '10',
                                originalSession: {
                                    req: {
                                        socket: {
                                            end: function () {}
                                        }
                                    },
                                    res: {
                                        writeHead: function () {},
                                        end: function () {}
                                    }
                                }
                            };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            try {
                expect(wrapped(0)).to.equal('10');
                done();
            }
            catch (err) {
                done(err);
            }
        });


        it('update a function and hijack its return value at post', { plan: 3 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        postCbs: [{ method: function () {

                            return { };
                        } }, { method: function () {

                            return { status: 'skip', newReturnValue: '5' };
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            expect(wrapped(0)).to.equal('5');
            expect(wrapped.prototype.fct(0)).to.equal(1);
            done();
        });

        it('update a function and hijack its return value at post - ignored because rule is in test', { plan: 3 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        postCbs: [
                            {
                                method: function () {

                                    return { status: 'skip', newReturnValue: '5' };
                                },
                                rule: {
                                    test: true
                                }
                            }
                        ]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            expect(wrapped(0)).to.equal(1);
            expect(wrapped.prototype.fct(0)).to.equal(1);
            done();
        });

        it.skip('update a function and raise its return value at post - skipped, we do not throw anymore', { plan: 2 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            fct.prototype = {
                fct
            };
            const module = {
                a: fct // ensure that infinte recusrions are not happenning
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                params: {
                    postCbs: [{ method: function () {

                        return { status: 'raise', stauts: 'nothing' };
                    } }]
                }
            });

            const wrapped = module.a;

            try {
                wrapped(0);
            }
            catch (err) {
                expect(err).to.exist();
            }
            done();
        });

        it('update a function and does not properly hijack its return value', { plan: 2 }, (done) => {

            const fct = function (x) {

                return x + 1;
            };
            Object.defineProperty(fct, 'ro', {
                t0: {
                    get: function () {

                        throw new Error();
                    }
                }
            });
            const module = {
                a: fct
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.a(1)).to.equal(fct(1));

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        preCbs: [
                            {
                                method: null
                            },
                            {
                                method: function () {

                                    return {};
                                }
                            },
                            {
                                method: function () {

                                    return { status: 1 };
                                }
                            },
                            {
                                method: function () {

                                    return { status: 'skip' };
                                }
                            }
                        ]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            expect(wrapped(0)).to.not.exist();
            done();
        });

        it('wrap a function*', { plan: 5 }, (done) => {

            const fct = function* idMaker(){

                let index = 0;
                while (index < 3){
                    yield index++;
                }
            };
            fct.a = 1;
            const module = {
                a: fct
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' }, 'name');

            expect(module.a()).to.equal(fct());

            const wrapped = module.a;

            expect(wrapped()).to.equal(fct());
            expect(wrapped.a).to.equal(fct.a);
            expect(wrapped.length).to.equal(fct.length);
            expect(wrapped.name).to.equal(fct.name);

            done();
        });

        it('update a function that throws', { plan: 3 }, (done) => {

            const fct = function () {

                throw new Error('my error');
            };
            const module = {
                a: fct
            };
            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            Director.update({
                moduleName: 'module1',
                methodName: 'a',
                file: 'lib/index.js',
                versions: '1.0.0',
                build: function () {

                    this.params = {
                        failCbs: [{ method: function (args, err) {

                            expect(err.message).to.equal('my error');
                        } }]
                    };
                },
                params: {}
            });

            const wrapped = module.a;

            try {
                wrapped();
            }
            catch (err) {
                expect(err).to.exist();
                expect(err.message).to.equal('my error');
            }
            done();
        });

        it('should wrap a named constructor', { plan: 3 }, (done) => {

            const fct = function F(x) {

                this.x = x;
            };
            fct.prototype.action = function () {

                return 2 * this.x;
            };
            const module = { 'a': fct };

            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a(10);
            expect(res).to.be.an.instanceof(fct);
            expect(res.x).to.equal(10);
            expect(res.action()).to.equal(20);
            done();
        });

        it('should wrap a constructor but accept unconstructed call too', { plan: 2 }, (done) => {

            const fct = function F(x) {

                this.x = x;
            };
            const module = { 'a': fct };

            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a();
            res.constructor = null;
            module.a.apply(res, [10]);
            expect(res).to.be.an.instanceof(fct);
            expect(res.x).to.equal(10);
            done();
        });

        it('should cover weird proto stuff', { plan: 2 }, (done) => {

            const fct = function F(x) {

                this.x = x;
            };
            const module = { 'a': fct };

            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a();
            const newProto = {};
            const proto = Object.getPrototypeOf(res);
            Object.setPrototypeOf(res, newProto);
            Object.setPrototypeOf(newProto, proto);
            module.a.apply(res, [10]);
            expect(res).to.be.an.instanceof(fct);
            expect(res.x).to.equal(10);
            done();
        });

        it('should be a bit transparent', { plan: 1 }, (done) => {

            const fct = function F(x) {

                this.x = x;
            };
            const module = { 'a': fct };

            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a();
            expect(res.constructor).to.equal(module.a);
            done();
        });

        it('should wrap a unnamed constructor', { plan: 2 }, (done) => {

            const fct = function (x) {

                this.x = x;
            };
            const module = { 'a': fct };

            FunctionPatcher.patchFunction(module, 'a', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const res = new module.a(10);
            expect(res).to.be.an.instanceof(fct);
            expect(res.x).to.equal(10);
            done();
        });

        it('should not see a method as a constructor', { plan: 1 }, (done) => {

            const cstr = function F(x) {

                this.x = x;
            };
            cstr.prototype.getX = function () {

                return this.x;
            };

            FunctionPatcher.patchFunction(cstr.prototype, 'getX', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const obj = new cstr(10);
            const res = obj.getX();
            expect(res).to.equal(10);
            done();
        });

        it('should try to patch a read only method', { plan: 1 }, (done) => {

            const module = { ro: function () {} };
            Object.freeze(module);
            FunctionPatcher.patchFunction(module, 'ro', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.ro.__wrapped).to.not.exist();
            done();
        });

        /**
         * @skipped: there is no need to prevent patching of native code now that blind patching has been removed
         */
        it.skip('should try to patch native code', { plan: 1 }, (done) => {

            const module = { ro: Function.bind };
            FunctionPatcher.patchFunction(module, 'ro', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.ro.__wrapped).to.not.exist();
            done();
        });

        it('should try to patch already patched code', { plan: 1 }, (done) => {

            const module = { ro: function () {} };
            module.ro.__original = true;
            module.ro.__sqreenable = true;
            FunctionPatcher.patchFunction(module, 'ro', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.ro.__wrapped).to.not.exist();
            done();
        });

        it('should try to patch non existing method', { plan: 1 }, (done) => {

            const module = { ro: function () {} };
            module.ro.__original = true;
            FunctionPatcher.patchFunction(module, 'ra', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            expect(module.ro.__wrapped).to.not.exist();
            done();
        });

        it('should try to patch a method without prototype', { plan: 1 }, (done) => {

            const module = { ro: function () {} };
            module.ro.prototype = null;
            FunctionPatcher.patchFunction(module, 'ro', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            module.ro();
            expect(module.ro.__wrapped).to.be.true();
            done();
        });

        it('should try to patch Buffer', { plan: 2 }, (done) => {

            const module = { buffer: Buffer };
            FunctionPatcher.patchFunction(module, 'buffer', { name: 'module1', version: '1.0.0', relativePath: 'lib/index.js' });

            const bf = new module.buffer('abc', 'utf-8');
            expect(Buffer.isBuffer(bf)).to.be.true();
            expect(bf.toString()).to.equal('abc');
            done();
        });
    });
});
