/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const beforeEach = lab.beforeEach;
const afterEach = lab.afterEach;

const Proxyquire = require('proxyquire');
const SqreenSDK = require('sqreen-sdk');
const PPatch = require('../../../lib/instrumentation/patch');
const Record = require('../../../lib/instrumentation/record');

const Budget = require('../../../lib/instrumentation/budget');

const INFINITY = Budget.INFINITY;
const ZERO = Budget.ZERO;

describe('Patch', () => {

    beforeEach((done) => {

        Budget.ZERO = INFINITY;
        require('../../../lib/command/features').featureHolder.use_signals = true;
        done();
    });

    afterEach((done) => {

        Budget.ZERO = ZERO;
        require('../../../lib/command/features').featureHolder.use_signals = false;
        done();
    });

    describe('dropRequest', () => {

        it('should throw in secret', { plan: 1 }, (done) => {

            const RUtils = require('../../../lib/rules/rules-callback/utils');
            const o = RUtils.dropRequest;
            RUtils.dropRequest = function () {

                expect(1).to.equal(1);
            };
            require('../../../lib/command/features').featureHolder.synchronous_blocking = true;
            process.nextTick(() => {

                require('../../../lib/command/features').featureHolder.synchronous_blocking = false;
                RUtils.dropRequest = o;
                done();
            });

            PPatch.dropRequest({}, {});
            done(new Error('should not have been called'));
        });
    });

    describe('isPromise', () => {

        it('should test the medthod', { plan: 6 }, (done) => {

            const isPromise = require('../../../lib/instrumentation/patch').isPromise;
            expect(isPromise(Promise.resolve())).to.be.true();
            expect(isPromise(undefined)).to.be.false();
            expect(isPromise(null)).to.be.false();
            expect(isPromise({})).to.be.false();
            expect(isPromise({ then: '1' })).to.be.false();
            expect(isPromise({ then: () => {}, catch: '1' })).to.be.false();
            done();
        });
    });

    describe('observe', () => {

        it('should work with null request', { plan: 0 }, (done) => {

            const Observe = require('../../../lib/instrumentation/patch')._observe;
            Observe({ session: { req: null }, observations: [] }, null, null);
            done();
        });
    });

    describe('_report', () => {

        it('should not report an attack', { plan: 0 }, (done) => {

            const Report = require('../../../lib/instrumentation/patch')._report;
            Report();
            done();
        });

        it('should report an attack without rule', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal(undefined);
                    expect(pl.rulespack_id).to.equal(undefined);
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            }, null, null);
        });

        it('should report an attack', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            }, null, null);
        });

        it('should report a replayed attack', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        __sqreen_replayed: true,
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            }, null, null);
        });

        it('should report an attack without reveal', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                },
                '../fuzzer': {
                    hasFuzzer: () => false
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        __sqreen_replayed: true,
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            }, null, null);
        });

        it('should report an attack', { plan: 3 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.headers).to.not.exist();
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {}
            }, null, null);
        });

        it('should report an attack to Record', { plan: 1 }, (done) => {

            const req = {
                __sqreen_uuid: 10
            };
            const record = new Record.RecordTrace(req, '', false);

            record.attack = function (ruleName) {

                expect(ruleName).to.equal('rule');
                done();
            };

            const Report = require('../../../lib/instrumentation/patch')._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req
                }
            }, null, record);
        });

        it('should report an attack to Record without rule', { plan: 1 }, (done) => {

            const req = {
                __sqreen_uuid: 10
            };
            const record = new Record.RecordTrace(req);

            record.attack = function (name) {

                expect(name).to.equal(undefined);
                Record.STORE.delete(10);
                done();
            };

            const Report = require('../../../lib/instrumentation/patch')._report;

            Report({
                record: 'infos',
                params: 'params',
                session: {
                    req
                }
            }, null, record);
        });

        it.skip('should report an attack in whitelisted path', { plan: 8 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    expect(pl.block).to.equal(false);
                    expect(pl.whitelist_match).to.equal('/admin/');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        headers: {
                            'x-forwarded-for': '192.168.0.1',
                            host: 'localhost:3000'
                        },
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        },
                        rawHeaders: []
                    }
                }
            }, null, '/admin/');
        });

        it('should report an attack', { plan: 5 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        }
                    }
                }
            }, null, null);
        });

        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {}
            }, null, null);
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {}
            }, null, null);
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {
                    req: {
                        headers: {},
                        connection: {},
                        rawHeaders: [
                            'x-forwarded-for', 'a',
                            'x-cluster-client-ip', 'b'
                        ]
                    }
                }
            }, null, null);
        });
    });

    describe('_actOnCbResult', () => {

        it('should not not do anything if the list is empty', { plan: 1 }, (done) => {

            const Patch = require('../../../lib/instrumentation/patch');

            const res = Patch._actOnCbResult([]);
            expect(res).to.not.exist();
            done();
        });

        it('should record observations', { plan: 4 }, (done) => {

            const req = {
                __sqreen_uuid: 100
            };
            const record = new Record.RecordTrace(req);

            record.observe = function (list) {

                expect(list).to.be.an.array();
                expect(list).to.have.length(1);
                expect(list[0]).to.be.an.array();
                expect(list[0]).to.have.length(3);

                done();
            };

            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult([
                {
                    session: { req },
                    observations: [['PONEY', 'MITSY', 1]]
                }
            ]);
        });

        it('should record data points', { plan: 6 }, (done) => {

            const req = {
                __sqreen_uuid: 100
            };
            const record = new Record.RecordTrace(req);
            expect(record._meta.mustReport).to.be.false();


            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult([
                {
                    session: { req },
                    rule: { name: 'rulename', rulesPack: 'rulesPackId' },
                    data_points: [{ hello: 'world' }, { 'good night': 'earth' }]
                }
            ]);

            expect(record.data).to.have.length(2);
            expect(record.data[0].signal_name).to.equal('rule:rulesPackId:rulename');
            expect(record.data[0].payload).to.equal({ hello: 'world' });
            expect(record.data[1].payload).to.equal({ 'good night': 'earth' });
            expect(record._meta.mustReport).to.be.true();
            done();
        });

        it('should record data points', { plan: 1 }, (done) => {

            const Patch = require('../../../lib/instrumentation/patch');
            const Shimmer = require('shimmer');
            const DP = require('../../../lib/data_point/index').DataPoint;
            Shimmer.wrap(DP, 'reportList', () => {

                return function (list) {

                    expect(list[0].signal_identifier).to.equal('rule:rulename:rulesPackId');
                };
            });

            Patch._actOnCbResult([
                {
                    rule: { name: 'rulename', rulesPack: 'rulesPackId' },
                    data_points: [{ hello: 'world' }]
                }
            ]);
            DP.reportList.__unwrap();
            done();
        });

        it('should send fuzzer signals to the fuzzer', { plan: 0 }, (done) => {

            const req = {
                __sqreen_replayed: true
            };

            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult([
                {
                    session: { req },
                    rule: { name: 'rulename', rulesPack: 'rulesPackId' },
                    fuzzer_signals: [{
                        trace: 'test',
                        metric: { key: 'test.metric', value: 'test', type: 1 }
                    }]
                }
            ]);
            done();
        });

        it('should record observations with originalSession', { plan: 4 }, (done) => {

            const req = {
                __sqreen_uuid: 100
            };
            const record = new Record.RecordTrace(req);

            record.observe = function (list) {

                expect(list).to.be.an.array();
                expect(list).to.have.length(1);
                expect(list[0]).to.be.an.array();
                expect(list[0]).to.have.length(3);

                done();
            };

            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult([
                {
                    originalSession: { req },
                    observations: [['PONEY', 'MITSY', 1]]
                }
            ]);
        });

        it('should call raise events', { plan: 1 }, (done) => {

            const req = {
                __sqreen_uuid: 100
            };

            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult(
                [
                    {
                        status: 'raise'
                    }
                ],
                {
                    req,
                    raw: {
                        get: function () {

                            const res = new Map();
                            res.set('aa', (x) => {

                                expect(x).to.not.exist();
                                done();
                            });
                            return res;
                        }
                    }
                });
        });

        it('should not skip even if the rule is in test because of SQREEN_BLOCK_ALL', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../config': {
                    getConfig: function () {

                        return {
                            block_all_rules: true
                        };
                    }
                }
            });

            const res = Patch._actOnCbResult([{ status: 'skip', rule: { test: true } }], { req: { __sqreen_url: '/' } });
            expect(res.status).to.equal('skip');
            done();
        });

        it('should not skip even if the rule is in test because of SQREEN_BLOCK_ALL but fail with metric reporting', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function () {

                        throw new Error();
                    }
                },
                '../exception': {
                    report: function (e) {

                        expect(e).to.exist();
                        done();
                        return Promise.reject();
                    }
                }
            });
            Patch._actOnCbResult([{ observations: [] }], { req: { __sqreen_url: '/' } });
        });

        it('should not skip even if the rule is in test because of SQREEN_BLOCK_ALL but fail with metric reporting', { plan: 3 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function () {

                        throw new Error(); // get called twice
                    }
                },
                '../exception': {
                    report: function (e) {

                        expect(e).to.exist();
                        return Promise.reject();
                    }
                }
            });
            Patch._actOnCbResult([{ observations: [], status: 'raise' }], { req: { __sqreen_url: '/' }, res: {} });
            done();
        });
    });

    describe('removeAllCallbacks', () => {

        it('should remove all callbacks from patches', { plan: 4 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                './sqreenDirector': {
                    register: function () { }
                }
            });

            const p1 = new Patch({ a: function (){} }, 'a');
            p1.hasCbs = true;
            p1.preCbs.push({ x: 1 });

            expect(p1.hasCbs).to.be.true();
            expect(p1.preCbs).to.have.length(1);
            Patch.removeAllCallbacks();
            expect(p1.hasCbs).to.be.false();
            expect(p1.preCbs).to.have.length(0);
            done();
        });
    });

    describe('_logExec', () => {

        it('should collect call count', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function (arr) {

                        expect(arr[0]).to.equal(['sqreen_call_counts', '1/name/pre', 3]);
                        done();
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            call_counts_metrics_period: true
                        };
                    }
                }
            });

            Patch._logExec([
                { rule: {} },
                {},
                { rule: { call_count_interval: 0 } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } }
            ], 'pre');

        });

        it('should collect call count to a legacy metric', { plan: 1 }, (done) => {

            require('../../../lib/command/features').featureHolder.use_signals = false;
            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../../lib_old/metric': {
                    addObservations: function (arr) {

                        expect(arr[0]).to.equal(['sqreen_call_counts', '1/name/pre', 3]);
                        require('../../../lib/command/features').featureHolder.use_signals = true;
                        done();
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            call_counts_metrics_period: true
                        };
                    }
                }
            });

            Patch._logExec([
                { rule: {} },
                {},
                { rule: { call_count_interval: 0 } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } }
            ], 'pre');

        });

        it('should not collect call count', { plan: 0 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function () {

                        done(new Error('should not have been called'));
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            call_counts_metrics_period: false
                        };
                    }
                }
            });

            Patch._logExec([
                { rule: {} },
                {},
                { rule: { call_count_interval: 0 } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } }
            ], 'pre');
            done();

        });
    });

    describe('instrumented', () => {

        const Patch = require('../../../lib/instrumentation/patch');

        it('should not construct with cb', { plan: 3 }, (done) => {

            const original = function () {

                return 1;
            };
            const patch = new Patch(original, {}, '', '');

            patch.hasCbs = true;

            const obj1 = { __sqreen_constructed: true };
            expect(patch.instrumented.apply(obj1)).to.equal(1);

            const obj2 = {};
            Object.setPrototypeOf(obj2, null);
            expect(patch.instrumented.apply(obj2)).to.equal(1);

            const obj3 = new patch.instrumented();
            expect(obj3.__sqreen_constructed).to.be.true();

            done();
        });

        it('should not construct with cb that return frozzen objects', { plan: 1 }, (done) => {

            const original = function () {

                this.x = 1;
                Object.freeze(this);
            };
            const patch = new Patch(original, {}, '', '');

            const obj = new patch.instrumented();

            expect(obj.__sqreen_constructed).to.not.exist();

            done();
        });

        it('should not change the prototype', { plan: 2 }, (done) => {

            const original = function () {

                return 1;
            };
            Object.setPrototypeOf(original, null);
            original.prototype = { a: 1 };
            const patch = new Patch(original, {}, '', '');

            expect(Object.getPrototypeOf(patch.instrumented)).to.equal(null);
            expect(patch.instrumented.prototype).to.equal({ a: 1 });

            done();
        });

        it('should have an error in call but not catch it', { plan: 1 }, (done) => {

            const original = function (x) {

                throw x;
            };
            const patch = new Patch(original, {}, '', '');
            patch.hasCbs = true;
            patch.preCbs = [{
                method: function (args) {

                    args[0] = 1;
                }
            }];

            try {
                patch.instrumented(0);
            }
            catch (e) {
                expect(e).to.equal(1);
                done();
            }
        });
    });

    describe('performRecordAndObservation', () => {

        it('should write a standalone signal', { plan: 2 }, (done) => {

            SqreenSDK.initBatch(10, 10000, (batch) => {

                expect(batch).to.have.length(1);
                const item = batch[0];
                delete item.time; // would make test fail
                expect(item).to.equal({
                    type: 'point',
                    signal_name: 'signame',
                    actor: undefined,
                    location_infra: undefined,
                    location: undefined,
                    source: 'single_point:rpid:rname',
                    trigger: undefined,
                    payload_schema: 'reveal_point',
                    payload: { hello: 'world' },
                    context_schema: undefined,
                    context: undefined
                });
                done();
                return Promise.resolve();
            });
            PPatch._performRecordAndObservation([{
                rule: {
                    rulespack: 'rpid',
                    name: 'rname'
                },
                single_point: [{
                    signal_name: 'signame',
                    payload_schema: 'reveal_point',
                    payload: { hello: 'world' }
                }]
            }]);
            SqreenSDK.Signal.prototype.BATCH.report();
        });

        it('should cover performRecordAndObservation', { plan: 0 }, (done) => {

            PPatch._performRecordAndObservation([
                {
                    session: {
                        req: null
                    },
                    record: {},
                    observations: [],
                    data_points: [],
                    payload: true
                }
            ]);
            const req = { __sqreen_uuid: 'sadkjhsdfkljahs' };
            new Record.RecordTrace(req, '', true);
            PPatch._performRecordAndObservation([
                {
                    session: {
                        req
                    },
                    record: { isLegacyRecord: true },
                    observations: [],
                    data_points: [],
                    payload: true
                }
            ]);
            PPatch._performRecordAndObservation([
                {
                    session: {
                        req
                    },
                    observations: [],
                    data_points: [],
                    payload: true
                }
            ]);
            PPatch._performRecordAndObservation([
                {
                    session: {
                        req
                    },
                    data_points: [],
                    payload: true
                }
            ]);
            PPatch._performRecordAndObservation([
                {
                    session: {
                        req
                    },
                    payload: true
                }
            ]);
            done();
        });
    });

    describe('Legacy records path', () => {

        const OldRecord = require('../../../lib_old/instrumentation/record');
        beforeEach((done) => {

            Budget.ZERO = INFINITY;
            require('../../../lib/command/features').featureHolder.use_signals = false;
            done();
        });

        afterEach((done) => {

            Budget.ZERO = ZERO;
            done();
        });

        it('create legacy attacks', { plan: 1 }, (done) => {

            const req = {
                __sqreen_uuid: 10
            };
            const record = new OldRecord.Record(req, '');

            const Report = require('../../../lib/instrumentation/patch')._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req
                }
            }, null, record);
            expect(record.observed.attacks).to.have.length(1);
            done();
        });

        it('should record data points to legacy record', { plan: 6 }, (done) => {

            const req = {
                __sqreen_uuid: 100
            };
            const record = new OldRecord.Record(req);

            const Patch = require('../../../lib/instrumentation/patch');

            Patch._actOnCbResult([
                {
                    session: { req },
                    rule: { name: 'rulename', rulesPack: 'rulesPackId' },
                    data_points: [{ hello: 'world' }, { 'good night': 'earth' }]
                }
            ]);

            expect(record.observed.data_points.length).to.equal(2);
            expect(record.observed.data_points[0].signal_identifier).to.equal('rule:rulesPackId:rulename');
            expect(record.observed.data_points[0].infos).to.equal({ hello: 'world' });
            expect(record.observed.data_points[1].infos).to.equal({ 'good night': 'earth' });
            expect(record.shouldReport()).to.be.true();
            record.observed.sqreen_exceptions.push({}); // coverage
            expect(record.shouldReport()).to.be.true();
            done();
        });

    });

    describe('ecosystem cases', () => {

        it('should cover ecosystem cases', { plan: 5 }, (done) => {

            const resolves = [];
            const fct = function () {

                return new Promise((resolve) => {

                    resolves.push(resolve);
                });
            };
            const patch = new PPatch(fct, {}, 'hello', 'world');
            expect(PPatch.getPatchFromOriginal(fct)).to.equal(patch);
            const ns = require('../../../lib/instrumentation/hooks/ns').getNSByName('my test ns that must not collide 45324');

            const values = [354, 654];
            let call = 0;
            const pre = {
                method: function () {

                    const context = Object.create(null);
                    ns.enter(context);
                    ns.set('a', values[call]);
                    ++call;
                }
            };
            const post = {
                method: function () {

                    ns.exit(ns.active);
                }
            };
            const asyncPost = {
                method: function () {

                    if (call === 0) {
                        expect(ns.get('a')).to.equal(values[1]);
                    }
                    else {
                        expect(ns.get('a')).to.equal(values[0]);
                    }
                }
            };

            const fail = {
                method: function () {
                }
            };

            patch.addEcosystemCallbacks(pre, post);
            patch.addEcosystemCallbacks(null, null, asyncPost, fail);

            patch.instrumented()
                .then((res) => {

                    expect(res).to.equal(10);
                    done();
                });

            patch.instrumented()
                .then((res) => {

                    expect(res).to.equal(100);
                    resolves[0](10);
                });
            resolves[1](100);
        });
    });
});
