/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;
const beforeEach = lab.beforeEach;
const afterEach = lab.afterEach;

const Patcher = require('../../../lib/instrumentation/patcher');

const Budget = require('../../../lib/instrumentation/budget');

const INFINITY = Budget.INFINITY;
const ZERO = Budget.ZERO;

describe('patcher', () => {

    beforeEach((done) => {

        Budget.ZERO = INFINITY;
        done();
    });

    afterEach((done) => {

        Budget.ZERO = ZERO;
        done();
    });

    describe('patchModule', () => {

        beforeEach((done) => {

            Patcher._init();
            done();
        });

        it('should do nothing if there is no module', { plan: 2 }, (done) => {

            const result = Patcher.patchModule(null, {}, 'aa');
            expect(result).to.not.exist();
            expect(Patcher._savedModules).to.equal({});
            done();
        });

        it('should patch an exported function', { plan: 2 }, (done) => {

            const HardPatches = require('../../../lib/instrumentation/hardPatches');
            HardPatches.mySqModule = ['lib/index.js'];
            const module = function () {

                return 10;
            };

            const result = Patcher.patchModule(module, { name: 'mySqModule', relativePath: 'lib/index.js' }, 'mod');
            expect(result.__wrapped).to.be.true();
            const result2 = Patcher.patchModule(module, { name: 'mySqModule', relativePath: 'lib/main.js' }, 'mod');
            expect(result2.__wrapped).to.not.exist();
            done();
        });

        it('should get a pointer on a module for patching', { plan: 6 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', version: 1 }, 'mod');

            expect(result1).to.equal(module);
            expect(Patcher._savedModules.module).to.be.an.array();
            expect(Patcher._savedModules.module).to.have.length(1);
            expect(Patcher._savedModules.module[0].identity).to.equal({ name: 'module', version: 1 });
            expect(Patcher._savedModules.module[0].patched).to.equal([]);
            expect(Patcher._savedModules.module[0].module).to.equal(module);

            done();
        });

        it('should patch eval', { plan: 3 }, (done) => {

            /*eslint-disable */

            const ev = global.eval;
            expect(eval).to.equal(ev);

            Patcher.placePatch({ moduleName: 'global', methodName: 'eval' });
            expect(eval).to.not.equal(ev);
            expect(eval('1 + 1')).to.equal(2);
            /*eslint-enable */


            done();
        });

        it('should patch RegExp.prototype.exec', { plan: 1 }, (done) => {

            // Patcher.patchModule({ moduleName: 'global', methodName: 'Regexp.prototype:exec' });
            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'global.RegExp.prototype',
                methodName: 'exec',
                build() {},
                params: {
                    preCbs: [
                        {
                            method: function (_1, _2, _3, selfObject) {

                                expect(selfObject.toString()).to.equal('/a/');
                            }
                        }
                    ]
                }
            });
            /a/.exec('aaa');
            RegExp.prototype.exec.__unwrap();
            done();
        });

        it('should patch process.stdout.write', { plan: 1 }, (done) => {

            // Patcher.patchModule({ moduleName: 'global', methodName: 'Regexp.prototype:exec' });
            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'global.process.stdout',
                methodName: 'write',
                build() {},
                params: {
                    preCbs: [
                        {
                            method: function (args) {

                                expect(args[0].toString()).to.equal('hello world');
                            }
                        }
                    ]
                }
            });
            console.log('hello world');
            process.stdout.write.__unwrap();
            done();
        });

        it('should get a pointer on a module for patching', { plan: 6 }, (done) => {

            const module = function () {};
            module.a = function () {

                return 1;
            };

            const result1 = Patcher.patchModule(module, { name: 'module', version: 1 }, 'mod');

            expect(result1).to.equal(module);
            expect(Patcher._savedModules.module).to.be.an.array();
            expect(Patcher._savedModules.module).to.have.length(1);
            expect(Patcher._savedModules.module[0].identity).to.equal({ name: 'module', version: 1 });
            expect(Patcher._savedModules.module[0].patched).to.equal([]);
            expect(Patcher._savedModules.module[0].module).to.equal(module);

            done();
        });

        it('should get a pointer on a module (with internal file) for patching', { plan: 6 }, (done) => {

            const module = {
                a: function () {

                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', version: 1, relativePath: './index.js' }, 'mod');

            expect(result1).to.equal(module);
            expect(Patcher._savedModules['module:./index.js']).to.be.an.array();
            expect(Patcher._savedModules['module:./index.js']).to.have.length(1);
            expect(Patcher._savedModules['module:./index.js'][0].identity).to.equal({ name: 'module', version: 1, relativePath: './index.js' });
            expect(Patcher._savedModules['module:./index.js'][0].patched).to.equal([]);
            expect(Patcher._savedModules['module:./index.js'][0].module).to.equal(module);

            done();
        });

        it('should get a pointer on a module twice for patching', { plan: 10 }, (done) => {

            const module = {
                a: function () {

                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', version: 1 }, 'mod');
            const result2 = Patcher.patchModule(module, { name: 'module', version: 2 }, 'mod');

            expect(result1).to.equal(module);
            expect(result2).to.equal(module);
            expect(Patcher._savedModules.module).to.be.an.array();
            expect(Patcher._savedModules.module).to.have.length(2);
            expect(Patcher._savedModules.module[0].identity).to.equal({ name: 'module', version: 1 });
            expect(Patcher._savedModules.module[0].patched).to.equal([]);
            expect(Patcher._savedModules.module[0].module).to.equal(module);

            expect(Patcher._savedModules.module[1].identity).to.equal({ name: 'module', version: 2 });
            expect(Patcher._savedModules.module[1].patched).to.equal([]);
            expect(Patcher._savedModules.module[1].module).to.equal(module);

            done();
        });

        it.skip('should patch a function module', { plan: 8 }, (done) => {

            const module = function () {};
            module.a = module;

            Object.defineProperty(module, 'ge', {
                enumerable: true,
                get: function () {

                    return 1;
                }
            });

            module.b = 1;

            const result1 = Patcher.patchModule(module, { name: 'module', version: 6 }, 'mod');

            expect(result1.__original).to.equal(module);
            expect(Patcher._savedModules.module).to.be.an.array();
            expect(Patcher._savedModules.module).to.have.length(1);
            expect(Patcher._savedModules.module[0].identity).to.equal({ name: 'module', version: 6 });
            expect(Patcher._savedModules.module[0].patched).to.equal([]);
            expect(Patcher._savedModules.module[0].module).to.equal(module);
            expect(result1.__wrapped).to.be.true();
            expect(result1.a.__wrapped).to.be.true();

            done();
        });

        it.skip('should not patch a function module', { plan: 4 }, (done) => {

            const module = function () {};

            const result1 = Patcher.patchModule(module, { name: 'module', version: 6, internal: true });
            expect(result1.__wrapped).to.not.exist();

            const result2 = Patcher.patchModule(module, { name: 'module', version: 6, internal: false }, 'mod');
            expect(result2.__wrapped).to.be.true();

            const result3 = Patcher.patchModule(module, { name: 'module', version: 6, internal: false }, './mod');
            expect(result3.__wrapped).to.not.exist();

            const result4 = Patcher.patchModule(module, { name: 'module', version: 6, internal: false, forceHj: true }, './mod');
            expect(result4.__wrapped).to.be.true();

            done();
        });
    });
});

