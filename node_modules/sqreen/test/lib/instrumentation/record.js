'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Utils = require('../../testUtils');
const RecordPath = '../../../lib/instrumentation/record';
const SqreenSDK = require('sqreen-sdk');

require('../../../lib/command/features').featureHolder.use_signals = true;

const WAF_ATK_EX = {
    'rule_name': 'waf_node_express',
    'test': false,
    'block': false,
    'infos': {
        'waf_data': '[{"ret_code":2,"flow":"xss-blocking","step":"start","rule":"rule_941100","filter":[{"operator":"@detectXSS","binding_accessor":"#.filtered_request_params | flat_values","resolved_value":"1256-5465-5555-6666"}]}]'
    },
    'time': '2019-12-17T17:34:08.716Z',
    'backtrace': []
};

const WAF_ATK_SAN = {
    'type': 'point',
    'signal_name': 'sq.agent.attack.',
    'actor': undefined,
    context_schema: undefined,
    location_infra: undefined,
    'location': {
        'stack_trace': []
    },
    'source': 'sqreen:rule::waf_node_express',
    'trigger': undefined,
    payload_schema: 'attack/2020-01-01T00:00:00.000Z',
    'payload': {
        'test': false,
        'block': false,
        'beta': false,
        'infos': {
            'waf_data': '[{"ret_code":2,"flow":"xss-blocking","step":"start","rule":"rule_941100","filter":[{"operator":"@detectXSS","binding_accessor":"#.filtered_request_params | flat_values","resolved_value":"<Redacted by Sqreen>"}]}]'
        }
    },
    'context': undefined,
    'time': '2019-12-17T17:34:08.716Z'
};

describe('Record', () => {

    it('should cover the case when instrumentation is disabled', { plan: 0 }, (done) => {

        const Record = require('../../../lib/instrumentation/record');
        Record.switchInstru(false);
        const r = new Record.RecordTrace({}, '');
        r.close({}, {}, 0);
        Record.switchInstru(true);
        done();
    });

    it('should write a WAF attack that must be sanitized', { plan: 5 }, (done) => {

        const Config = require('../../../lib/config/index');
        const getConfig = Config.getConfig;
        Config.getConfig = function () {

            return {
                strip_sensitive_data: true,
                strip_sensitive_keys: ['password', 'secret', 'passwd', 'authorization', 'api_key', 'apikey', 'access_token'],
                strip_sentitive_regex: [/^(?:\d[ -]*?){13,16}$/]
            };
        };
        const RecordTrace = require('../../../lib/instrumentation/record').RecordTrace;
        require('../../../lib/instrumentation/record').switchInstru(true);
        const req = {
            url: '/pay?cc=1256-5465-5555-6666&dd=1256-5465-5555-6666',
            query: {
                cc: '1256-5465-5555-6666'
            }
        };
        const record = new RecordTrace(req, '134.23.5.2', true);
        record.attack(WAF_ATK_EX.rule_name, '', WAF_ATK_EX.test, WAF_ATK_EX.block, false, WAF_ATK_EX.infos, WAF_ATK_EX.time, WAF_ATK_EX.backtrace, '');
        expect(record._meta.wafAttack).to.exist();
        record.close(req, {}, 0);
        expect(record._meta).to.not.exist();
        expect(record.data[0]).to.equal(WAF_ATK_SAN);
        expect(record.context.request.parameters.query.cc).to.equal('<Redacted by Sqreen>');
        expect(record.context.request.path).to.equal('/pay?cc=<Redacted by Sqreen>&dd=<Redacted by Sqreen>');
        Config.getConfig = getConfig;
        done();
    });

    it('should create a record, fill it and close it', { plan: 8 }, (done) => {

        process.env.SQREEN_TOKEN = 'token';
        require('../../../lib/config/index').getConfig(true);

        const Record = require(RecordPath);
        Record.switchInstru(true);

        const x = {};
        x.x = x;

        const req = {
            __route: '/posts/:id',
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    Password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.RecordTrace(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);
        record.attack('ruleName', '', true, false, false, { a: 1 }, new Date(), (new Error('ruleName')).stack.split('\n'), 'aaa');

        const err = new Error('myErr');
        // klass, message, infos, ruleName, rulesPack, time, backtrace
        record.except(Error.name,
            err.message,
            {
                client_ip: null,
                args: []
            },
            'ruleName',
            new Date(),
            err.stack.split('\n')
        );
        record.except(TypeError.name, 'ok', null, undefined, undefined, new Date(), err.stack.split('\n'));
        record.addSDK('', []);
        record.addSDK('', [{}, {}]);

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, { statusCode: 200, getHeaders: () => ({ 'content-type': 'aaa', 'content-length': 10 }) }, 20);
        record.close(req, { statusCode: 200 }, 10);// coverage

        expect(record.context.request.endpoint).to.equal('/posts/:id');
        expect(record.context.request.headers).to.be.an.array();
        expect(record.context.request.headers[0]).to.be.an.array();
        expect(record.context.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '<Redacted by Sqreen>']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            Password: '<Redacted by Sqreen>',
            username: null
        }]);
        expect(Record.RecordTrace.prototype.BATCH.data.indexOf(record) > -1).to.be.true();
        done();
    });

    it('should create a record, fill it and close it', { plan: 8 }, (done) => {

        process.env.SQREEN_TOKEN = 'token';
        require('../../../lib/config/index').getConfig(true);

        const Record = require(RecordPath);
        Record.switchInstru(true);

        const x = {};
        x.x = x;

        const req = {
            __route: '/posts/:id',
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    Password: ['hello', 1, 'world'],
                    secret: {},
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.RecordTrace(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);
        record.attack('ruleName', '', true, false, false, { a: 1 }, new Date(), (new Error('ruleName')).stack.split('\n'), 'aaa');

        const err = new Error('myErr');
        // klass, message, infos, ruleName, rulesPack, time, backtrace
        record.except(Error.name,
            err.message,
            {
                client_ip: null,
                args: []
            },
            'ruleName',
            new Date(),
            err.stack.split('\n')
        );
        record.except(TypeError.name, 'ok', null, undefined, undefined, new Date(), err.stack.split('\n'));
        record.addSDK('', []);
        record.addSDK('', [{}, {}]);

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, { statusCode: 200, getHeaders: () => ({ 'content-type': 'aaa', 'content-length': 10 }) }, 20);
        record.close(req, { statusCode: 200 }, 10);// coverage

        expect(record.context.request.endpoint).to.equal('/posts/:id');
        expect(record.context.request.headers).to.be.an.array();
        expect(record.context.request.headers[0]).to.be.an.array();
        expect(record.context.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '<Redacted by Sqreen>']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            Password: '<Redacted by Sqreen>',
            secret: '<Redacted by Sqreen>',
            username: null
        }]);
        expect(Record.RecordTrace.prototype.BATCH.data.indexOf(record) > -1).to.be.true();
        done();
    });

    it('should create a record, fill it and close it without atomization', { plan: 6 }, (done) => {

        require('sqreen-sdk').initBatch(1, 100000, () => Promise.resolve());
        process.env.SQREEN_STRIP_SENSITIVE_DATA = '0';
        require('../../../lib/config/index').getConfig(true);
        const Record = require(RecordPath);
        Record.switchInstru(true);

        const x = {};
        x.x = x;

        const req = {
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.RecordTrace(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack('ruleName', '', true, false, false, { a: 1 }, new Date(), (new Error('ruleName')).stack.split('\n'), 'aaa');

        const err = new Error('myErr');
        // klass, message, infos, ruleName, rulesPack, time, backtrace
        record.except(Error.name,
            err.message,
            {
                client_ip: null,
                args: []
            },
            'ruleName',
            new Date(),
            err.stack.split('\n')
        );

        record.close(req,{ statusCode: 200 });// coverage
        record.close(req,{ statusCode: 200 });// coverage

        expect(record.context.request.headers).to.be.an.array();
        expect(record.context.request.headers[0]).to.be.an.array();
        expect(record.context.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '5555-5555-5555-5555']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: 'hello',
            username: null
        }]);
        process.env.SQREEN_STRIP_SENSITIVE_DATA = '1';
        require('../../../lib/config/index').getConfig(true);
        done();
    });

    it('should create a record, fill it and close it but not clean stuff', { plan: 7 }, (done) => {

        process.env.SQREEN_STRIP_SENSITIVE_DATA = '0';
        process.env.SQREEN_TOKEN = '0';
        require('../../../lib/config/index').getConfig(true);


        const Record = require(RecordPath);
        Record.switchInstru(true);

        const x = {};
        x.x = x;

        const req = {
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.RecordTrace(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack('ruleName', '', true, false, false, { a: 1 }, new Date(), (new Error('ruleName')).stack.split('\n'), 'aaa');

        const err = new Error('myErr');
        // klass, message, infos, ruleName, rulesPack, time, backtrace
        record.except(Error.name,
            err.message,
            {
                client_ip: null,
                args: []
            },
            'ruleName',
            new Date(),
            err.stack.split('\n')
        );

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, { statusCode: 200 });
        record.close(req, { statusCode: 200 });// coverage

        expect(record.context_schema).to.equal('http/2020-01-01T00:00:00.000Z');
        expect(record.context.request.headers).to.be.an.array();
        expect(record.context.request.headers[0]).to.be.an.array();
        expect(record.context.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '5555-5555-5555-5555']);
        expect(record.context.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: 'hello',
            username: null
        }]);
        process.env.SQREEN_STRIP_SENSITIVE_DATA = '1';
        require('../../../lib/config/index').getConfig(true);
        done();
    });


    it('should create a record, fill it with only a metric and close it', { plan: 5 }, (done) => {

        const eventStub = {
            writeEvent: function (type, content) {

                done(new Error('should not have been called'));
            }
        };
        const metricStub = {
            addObservations: function (arg) {

                expect(arg).to.be.an.array();
                expect(arg).to.have.length(1);
                expect(arg[0]).to.be.an.array();
                expect(arg[0]).to.have.length(3);
                done();
            }
        };

        Utils.validateStub(require('../../../lib/events'), eventStub);
        Utils.validateStub(require('../../../lib/metric'), metricStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub,
            '../metric': metricStub
        });
        Record.switchInstru(true);

        const req = {
            __sqreen_uuid: 'aa'
        };

        const record = new Record.RecordTrace(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.observe([['HTTP_CODE', 500, 1]], new Date());

        record.close(req);
    });

    it('should have a RR with perf mon', { plan: 3 }, (done) => {

        SqreenSDK.initBatch(10000, 10000, () => Promise.resolve());
        const Features = require('../../../lib/command/features');
        const Metrics = require('../../../lib/metric');
        Metrics.getAllReports(true);
        Features.change({ perf_level: 1, use_signals: true });
        Features.switchInstrumentationState(true);

        const Record = require(RecordPath);
        const requ = {};
        const record = Record.lazyGet(requ, '127.0.0.1');

        setTimeout(() => {

            record.close(requ, {},  500);

            Metrics.getAllReports(true);
            const data = SqreenSDK.Signal.prototype.BATCH.data;

            const req = data.find((x) => x.signal_name === 'sq.agent.metric.req');
            const sq = data.find((x) => x.signal_name === 'sq.agent.metric.sq');
            const pct = data.find((x) => x.signal_name === 'sq.agent.metric.pct');

            expect(req.payload.max).to.be.above(900);
            expect(sq.payload.max).to.equal(500);
            expect(pct.payload.max).to.be.above(.095);

            Features.change({ perf_level: 0 });
            done();
        }, 1000);
    });
});
