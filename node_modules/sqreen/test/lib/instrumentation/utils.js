/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Utils = require('../../../lib/instrumentation/utils');
const Domain = require('domain');

describe('InstrumentationUtils', () => {

    describe('blockSync', () => {

        it('should synchronously block a codepath', { plan: 0 }, (done) => {

            Utils.blockSync(() => {

                // TODO: assert no handler anymore
                done();
            });
            done(new Error('should not have been called'));
        });

        it('should synchronously block a codepath outside a domain', { plan: 0 }, (done) => {

            process.domain.exit();
            Utils.blockSync(() => {

                // TODO: assert no handler anymore
                done();
            });
            done(new Error('should not have been called'));
        });

        it('should synchronously block a codepath outside a domain and still allow handlers on process', { plan: 1 }, (done) => {

            process.domain.exit();
            const hand = (err) => {

                done(new Error('should not have been called ' + err.message));
            };
            process.on('uncaughtException', hand);
            Utils.blockSync(() => {

                // TODO: assert no handler anymore
                expect(process.listeners('uncaughtException')).to.include(hand);
                done();
            });
            done(new Error('should not have been called'));
        });


        it('should synchronously block a codepath outside a domain in a promise', { plan: 0 }, (done) => {

            process.domain.exit();
            process.removeAllListeners('unhandledRejection');
            Promise.resolve()
                .then(() => {

                    Utils.blockSync(() => {

                        // TODO: assert no handler anymore
                        done();
                    });
                })
                .then(() => {

                    done(new Error('should not have been called'));
                });
        });

        it('should fail to synchronously block a codepath outside a domain in a promise', { plan: 0 }, (done) => {

            process.domain.exit();
            Promise.resolve()
                .then(() => {

                    Utils.blockSync(() => {

                        // TODO: assert no handler anymore
                        done(new Error('should not have been called'));
                    });
                })
                .catch(() => {

                    done();
                });
        });

        it('should synchronously block a codepath with multiple domains', { plan: 3 }, (done) => {

            const d1 = Domain.create();
            d1.name = 'd1';
            d1.on('error', (e) => done(e));
            const d2 = Domain.create();
            d2.name = 'd2';
            d2.on('error', (e) => done(e));
            d1.enter();
            expect(process.domain).to.equal(d1);
            d2.enter();
            expect(process.domain).to.equal(d2);


            Utils.blockSync(() => {

                expect(process.domain).to.equal(d2);
                done();
            });
            done(new Error('should not have been called'));
        });

        it('should synchronously block a codepath without a domain', { plan: 0 }, (done) => {

            Utils.blockSync(() => {

                // TODO: assert no handler anymore
                done();
            });
            done(new Error('should not have been called'));
        });

        it('should fail to synchronously block a codepath', { plan: 2 }, (done) => {

            process.domain.exit();
            try {
                Utils.blockSync( () => done('Should not have been called'));
            }
            catch (e) {
                expect(e).to.exist();
            }
            try {
                throw new Error('it will ignore me');
            }
            catch (e) {
                expect(e).to.exist();
                done();
            }
        });
    });

    describe.skip('pathIsWhiteListed', () => {

        it('should find that the path is whitelisted or not', { plan: 6 }, (done) => {

            const list = ['/admin', '/me/'];

            expect(Utils.pathIsWhiteListed('/administration/', list)).to.equal('/admin');
            expect(Utils.pathIsWhiteListed('/admin/istration/', list)).to.equal('/admin');
            expect(Utils.pathIsWhiteListed('/me/you', list)).to.equal('/me/');
            expect(Utils.pathIsWhiteListed('/user', list)).to.equal('');
            expect(Utils.pathIsWhiteListed('', list)).to.equal('');
            expect(Utils.pathIsWhiteListed('/user/admin/me', list)).to.equal('');
            done();
        });
    });

    describe('getListSession', () => {

        it('should find the original session', { plan: 2 }, (done) => {

            expect(Utils.getListSession([{}, {}, { originalSession: { a: 1 } }, { originalSession: { a: 1 } }])).to.equal({ a: 1 });
            expect(Utils.getListSession([{}, {}])).to.not.exist();
            done();
        });
    });

    describe('collectRoutingTableAndReportIt', () => {

        it('should collect the routing table for an express app', { plan: 2 }, (done) => {

            const app = require('express')();
            app.get('/', () => {});
            Utils.collectRoutingTableAndReportIt(app, (err, table) => {

                expect(err).to.not.exist();
                expect(table).to.exist();
                done();
            });
        });

        it('should fail to collect the routing table for an express app', { plan: 2 }, (done) => {

            Utils.collectRoutingTableAndReportIt(null, (err, table) => {

                expect(err).to.exist();
                expect(table).to.not.exist();
                done();
            });
        });

        it('should also fail to collect the routing table for an express app', { plan: 2 }, (done) => {

            Utils.collectRoutingTableAndReportIt({}, (err, table) => {

                expect(err).to.exist();
                expect(table).to.not.exist();
                done();
            });
        });
    });
});
