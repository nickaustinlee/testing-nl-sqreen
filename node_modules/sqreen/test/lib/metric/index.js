/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();
const beforeEach = lab.beforeEach;

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Metric = require('../../../lib/metric');
const SqreenSDK = require('sqreen-sdk');

describe('Metric', () => {

    beforeEach((done) => {

        Metric._clearAllMetrics();
        require('../../../lib/command/features').featureHolder.use_signals = true;
        done();
    });

    describe('getMetric', () => {

        it('should work with a wrong call', { plan: 1 }, (done) => {

            const m = Metric.getMetric();
            expect(m).to.equal(null);
            done();
        });
    });

    it('should create a new metric and remove it', { plan: 2 }, (done) => {

        new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric._METRIC_STORE.has('login-fail')).to.be.true();
        Metric.removeMetricByName('login-fail');
        expect(Metric._METRIC_STORE.has('login-fail')).to.be.false();
        done();
    });

    it('should create new metrics and remove them by prefix', { plan: 6 }, (done) => {

        new Metric({
            kind: 'Sum',
            name: 'sq.1',
            period: 10
        });
        Metric.addObservations([['sq.2', 1]], new Date());
        new Metric({
            kind: 'Sum',
            name: 'sq2',
            period: 10
        });

        expect(Metric._METRIC_STORE.has('sq.1')).to.be.true();
        expect(Metric._METRIC_STORE.has('sq.2')).to.be.true();
        expect(Metric._METRIC_STORE.has('sq2')).to.be.true();
        Metric.removeMetricsByPrefix('sq.');
        expect(Metric._METRIC_STORE.has('sq.1')).to.be.false();
        expect(Metric._METRIC_STORE.has('sq.2')).to.be.false();
        expect(Metric._METRIC_STORE.has('sq2')).to.be.true();
        done();
    });


    it('should accept to create a new metric', { plan: 1 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);
        done();
    });

    it('should refuse to create a new metric', { plan: 2 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);

        try {
            new Metric({
                kind: 'Sum',
                name: 'login-fail',
                period: 10
            });
        }
        catch (err) {
            expect(err).to.exist();
            done();
        }
    });

    describe('addObservations', () => {

        it('should create a new metric and add observations to it', { plan: 3, timeout: 5000 }, (done) => {

            SqreenSDK.initBatch(100000, 111111, () => Promise.resolve());
            const rule = {
                name: 'rule',
                metrics: [
                    {
                        kind: 'Sum',
                        name: 'test',
                        period: 2
                    },
                    {
                        kind: 'none',
                        name: 'none',
                        period: 15
                    }
                ]
            };

            rule.metrics.forEach(Metric.getMetric);

            const observations = [['test', 'unicorn', 1], ['test', 'pony', 2], ['none', 'nono', 10]];

            Metric.addObservations(observations);
            Metric.addObservations([['test', 'unicorn', 1]]);
            const noneMetric = Metric.getMetricByName(rule.metrics[1].name);
            const metric = Metric.getMetricByName(rule.metrics[0].name);

            expect(noneMetric).to.not.exist();
            expect(metric).to.exist();
            setTimeout(() => {

                expect(metric.getSignal().payload.values).to.equal([{ key: 'unicorn', value: 2 }, { key: 'pony', value: 2 }]);
                done();
            }, 3000);

        });
    });

});
