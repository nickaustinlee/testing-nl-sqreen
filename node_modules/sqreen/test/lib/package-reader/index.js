/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Fs = require('fs');
const Path = require('path');

const Rimraf = require('rimraf');

const Reader = require('../../../lib/package-reader');
const Proxyquire = require('proxyquire');

describe('package-reader', () => {

    describe('getDependenciesHash', () => {

        it('should not find a package.json', { plan: 1 }, (done) => {

            const tmp = Path.join(__dirname, 'tmp');
            Fs.mkdirSync(tmp);
            const MockedReader = Proxyquire('../../../lib/package-reader', {
                '../config': {
                    getConfig: () => ({ app_root: tmp })
                }
            });
            MockedReader.getDependenciesHash((res) => {

                expect(res).to.have.length(0);
                Fs.rmdirSync(tmp);
                done();
            });
        });

        it('should not find a package.json', { plan: 1 }, (done) => {

            const tmp = Path.join(__dirname, 'tmp');
            Fs.mkdirSync(tmp);
            Fs.writeFileSync(Path.join(tmp, 'package.json'), '{');
            const MockedReader = Proxyquire('../../../lib/package-reader', {
                '../config': {
                    getConfig: () => ({ app_root: tmp })
                }
            });
            MockedReader.getDependenciesHash((res) => {

                expect(res).to.have.length(0);
                Fs.unlinkSync(Path.join(tmp, 'package.json'));
                Fs.rmdirSync(tmp);
                done();
            });
        });

        it('should return the hash of sqreen agent deps', { plan: 1 }, (done) => {

            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                done();
            });
        });

        it('should return the hash of sqreen agent deps with a readFile error', { plan: 1 }, (done) => {

            const readFile = Fs.readFile;

            Fs.readFile = function (x, y, cb) {

                Fs.readFile = readFile;
                return cb(new Error('I am an error'));
            };

            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                done();
            });
        });

        it('should return the hash of sqreen agent deps even is a file is malformed', { plan: 1 }, (done) => {

            Fs.writeFileSync(process.cwd() + '/node_modules/my_package.json', 'aaaaa');
            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                Fs.unlinkSync(process.cwd() + '/node_modules/my_package.json');
                done();
            });
        });

    });

    describe('readPackage', () => {

        it('should smoothly read the content of a json file', { plan: 2 }, (done) => {

            const json = { hello: 'world' };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should smoothly read the content of a json file when deps', { plan: 2 }, (done) => {

            const json = { hello: 'world', dependencies: { 'a.1': 1 } };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should smoothly read the content of a json file when devDeps', { plan: 2 }, (done) => {

            const json = { hello: 'world', devDependencies: { 'a.1': 1 } };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should not read the content of a malformed json file', { plan: 1 }, (done) => {

            Fs.writeFileSync('./tmp.json', '{');

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.not.exist();

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should not read the content of a non existing file', { plan: 1 }, (done) => {

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.not.exist();

            done();
        });
    });

    describe('listModules', () => {

        it('should return a rejected promise when the directory does not exist', { plan: 1 }, (done) => {

            Reader.listModules('./my_node_modules')
                .then(() => done(new Error('this should have failed')))
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should return a fulfiled promise with the path to the package.json files', { plan: 3 }, () => {

            Fs.mkdirSync(Path.join(process.cwd(), 'my_node_modules'));
            Fs.mkdirSync(Path.join(process.cwd(), 'my_node_modules', 'mod1'));
            Fs.mkdirSync(Path.join(process.cwd(), 'my_node_modules', 'mod1', 'node_modules'));
            Fs.symlinkSync(Path.join(process.cwd(), 'my_node_modules', 'mod1'), Path.join(process.cwd(), 'my_node_modules', 'mod1', 'node_modules', 'mod1'));
            Fs.writeFileSync(Path.join(process.cwd(), 'my_node_modules', 'mod1', 'package.json'), JSON.stringify({ name: 'sqreen' }));
            Fs.writeFileSync(Path.join(process.cwd(), 'my_node_modules', 'mod1', 'fakePackage.json'), JSON.stringify({ name: 'sqreen' }));

            return Reader.listModules('./my_node_modules')
                .then((list) => {

                    expect(list).to.exist();
                    expect(list).to.be.an.array();
                    expect(list).to.have.length(1);
                })
                .then(() => {

                    return new Promise((resolve) => {

                        Rimraf(Path.join(process.cwd(), 'my_node_modules'), () => {

                            return resolve();
                        });
                    });
                });
        });
    });

    describe('getDependencies', () => {

        it('should list the dependencies of sqreen', { plan: 5 }, () => {

            process.env.SQREEN_TOKEN = 'a';
            return Reader.getDependencies()
                .then((list) => {

                    expect(list.hash).to.be.a.string();
                    expect(list.hash).to.exist();
                    expect(list.deps).to.exist();
                    expect(list.deps).to.be.an.array();
                    expect(list.deps.length).to.be.above(200);
                    delete process.env.SQREEN_TOKEN;
                });
        });

        it('should list the dependencies of sqreen with provided hash', { plan: 6 }, () => {

            process.env.SQREEN_TOKEN = 'a';
            return Reader.getDependencies('hello')
                .then((list) => {

                    expect(list.hash).to.be.a.string();
                    expect(list.hash).to.exist();
                    expect(list.hash).to.equal('hello');
                    expect(list.deps).to.exist();
                    expect(list.deps).to.be.an.array();
                    expect(list.deps.length).to.be.above(200);
                    delete process.env.SQREEN_TOKEN;
                });
        });

        it('should list the dependencies of sqreen with provided hash and also try to go upstairs (coverage)', { plan: 6 }, () => {

            process.env.SQREEN_TOKEN = 'a';
            process.env.SQREEN_USE_WORKSPACE = '1';
            return Reader.getDependencies('hello')
                .then((list) => {

                    expect(list.hash).to.be.a.string();
                    expect(list.hash).to.exist();
                    expect(list.hash).to.equal('hello');
                    expect(list.deps).to.exist();
                    expect(list.deps).to.be.an.array();
                    expect(list.deps.length).to.be.above(200);
                    delete process.env.SQREEN_TOKEN;
                    delete process.env.SQREEN_USE_WORKSPACE;
                });
        });

        it('should list the dependencies of sqreen', { plan: 4 }, () => {

            process.env.SQREEN_APP_ROOT = process.cwd() + '/test';
            const MockedReader = Proxyquire('../../../lib/package-reader', {
                '../safeUtils': {
                    guessRoot: () => process.cwd()
                }
            });
            process.env.SQREEN_TOKEN = 'a';
            return MockedReader.getDependencies()
                .then((list) => {

                    expect(list).to.exist();
                    expect(list.deps).to.be.an.array();
                    expect(list.deps.length).to.be.above(200);
                    expect(!!list.deps.find((x) => x.name === '@hapi/hoek')).to.be.true();
                    delete process.env.SQREEN_TOKEN;
                    delete process.env.SQREEN_APP_ROOT;
                });
        });

        it('should reject and not list the dependencies if \'node_modules\' does not exist', { plan: 1 }, (done) => {

            const paths = require.main.paths;
            require.main.paths = [];
            process.env.SQREEN_TOKEN = 'aaa';
            process.env.SQREEN_APP_ROOT = process.cwd() + '/test';
            const baseDir = process.cwd();
            process.chdir('./test');

            Reader.getDependencies()
                .then(() => done(new Error('this should have failed')))
                .catch((x) => {

                    expect(x).to.exist();
                    process.chdir(baseDir);
                    delete process.env.SQREEN_TOKEN;
                    delete process.env.SQREEN_APP_ROOT;
                    require.main.paths = paths;
                    done();
                });
        });
    });

});

