/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();
const Hoek = require('../../../../vendor/hoek/lib');

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Decache = require('decache');
const Shimmer = require('shimmer');

const run = function () {

    describe('getBaAndTransformerName', () => {

        it.skip('should find the transformer name', { plan: 1 }, (done) => {

            const Lib = require('../../../../lib/rules/rules-callback/libSqreenCB');
            expect(Lib.getBaAndTransformerName('left | right')).to.equal({ ba: 'left', transformer: 'right', key: 'left | right' });
            done();
        });
    });

    describe('limitObject', () => {

        it('should cleanup an object without side effects', { plan: 7 }, (done) => {

            const obj = {
                a: [1, 2, 3, 4, { a: 'a'.repeat(40000) }],
                b: [1, 2, 3, 4, { a: 'a'.repeat(10) }],
                r: null,
                c: 'hello',
                d: /aa/,
                e: {
                    f: {
                        g: {
                            h: {
                                i: {
                                    j: {
                                        k: {
                                            l: {
                                                m: {
                                                    n: {
                                                        o: {
                                                            p: {
                                                                q: {
                                                                    r: {
                                                                        s: {
                                                                            t: {
                                                                                u: {
                                                                                    v: {
                                                                                        w: {
                                                                                            x: {
                                                                                                y: {
                                                                                                    z: 'lol'
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                m: 'b'.repeat(30000)
            };

            const clone = Hoek.clone(obj);
            const newObj = require('../../../../lib/rules/rules-callback/utils').limitObject(obj, 0);

            expect(obj).to.equal(clone);
            expect(newObj.b === obj.b).to.be.true();
            expect(newObj.c === obj.c).to.be.true();
            expect(newObj.d === obj.d).to.be.true();
            expect(newObj.e !== obj.e).to.be.true();
            expect(newObj).to.equal({
                a: [1, 2, 3, 4, { a: 'a'.repeat(4 * 1024) }],
                b: [1, 2, 3, 4, { a: 'a'.repeat(10) }],
                c: 'hello',
                r: null,
                d: /aa/,
                e: {
                    f: {
                        g: {
                            h: {
                                i: {
                                    j: {
                                        k: {
                                            l: {
                                                m: {
                                                    n: {
                                                        o: {
                                                            p: {
                                                                q: {
                                                                    r: {
                                                                        s: null
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                m: 'b'.repeat(4 * 1024)
            });

            const o2 = { a: 1000 };
            expect(require('../../../../lib/rules/rules-callback/utils').limitObject(o2, 0) === o2).to.be.true();

            done();
        });
    });

    it('should not instanciate the callback', (done) => {

        Decache('../../../../lib/rules/rules-callback');
        const GetCB = require('../../../../lib/rules/rules-callback/libSqreenCB').getCbs;
        let fst = true;
        const preGyp = require('node-pre-gyp');
        Shimmer.wrap(preGyp, 'find', () => {

            return function () {

                if (!fst) {
                    preGyp.find.__unwrap();
                }
                fst = false;
                throw new Error('blah');
            };
        });
        let fst2 = true;
        const Message = require('../../../../lib/agent_message');
        Shimmer.wrap(Message.prototype, 'report', () => {

            return function () {

                if (this.signal_name !== 'sq.agent.message.no_sq-native') {
                    return Promise.resolve();
                }

                if (!fst2) {
                    done(new Error('should not have been called.'));
                    return Promise.resolve();
                }
                fst2 = false;
                Message.prototype.report.__unwrap();
                expect(this.payload.message).to.equal('Could not load sq-native');
                return Promise.resolve();
            };
        });

        try {
            GetCB();
        }
        catch (e) {
            expect(e).to.exist();
            try {
                GetCB();
            }
            catch (e2) {
                expect(e2).to.exist();
                return done();
            }
        }
        done(new Error('should not have been called.'));
    });

    it('should properly test the callabck', { plan: 7 }, (done) => {

        const GetCB = require('../../../../lib/rules/rules-callback').LibSqreenCB;
        let cb = GetCB({
            data: {
                values: {
                    max_budget_ms: 10,
                    binding_accessors: ['#.client_ip', '#.req[\'headers\'][\'head\']'],
                    waf_rules: '{"rules":[{"rule_id":"1","filters":[{"operator":"@rx","targets":["#.client_ip"],"value":"127.0.0.1"}]}],"flows":[{"name":"flow1","steps":[{"id":"start","rule_ids":["1"],"on_match":"exit_block"}]}]}'
                }
            }
        });

        expect(cb.pre).to.exist();
        const req = {
            headers: {
                'x-forwarded-for': '127.0.0.1',
                head: 'hello'
            },
            connection: {
                remoteAddress: '127.0.0.1'
            }
        };
        const res0 = cb.pre(null, null, null, null, { }, 100000);
        expect(res0).to.equal(null);

        const res02 = cb.pre(null, null, null, null, { req: { headers: {} } }, Infinity);
        expect(res02).to.equal({ status: null });

        const res = cb.pre(null, null, null, null, { req }, 100000);
        expect(res.status).to.equal(null);
        expect(res.record).to.exist();

        cb = GetCB({
            block: true,
            data: {
                values: {
                    binding_accessors: ['#.client_ip', '#.req[\'headers\'][\'head\']'],
                    waf_rules: '{"rules":[{"rule_id":"1","filters":[{"operator":"@rx","targets":["#.client_ip"],"value":"127.0.0.1"}]}],"flows":[{"name":"flow1","steps":[{"id":"start","rule_ids":["1"],"on_match":"exit_block"}]}]}'
                }
            }
        });

        const res3 = cb.pre(null, null, null, null, { req }, 100000);
        expect(res3.status).to.equal('raise');
        expect(res3.record).to.exist();

        done();
    });

    it('should properly test the callabck with default BAs', { plan: 3 }, (done) => {

        const GetCB = require('../../../../lib/rules/rules-callback').LibSqreenCB;
        const cb = GetCB({
            data: {
                values: {
                    max_budget_ms: 10,
                    binding_accessors: [
                        { ba: '#.req[\'headers\'][\'head\']', default: 'pony0' },
                        { ba: '#.req[\'headers\'][\'head2\']', default: 'pony2' },
                        { ba: '#.req[\'headers\'][\'head232\'][\'aaa\']', default: 'pony6' },
                        { ba: '#.sess[\'url\'] | url_decode' },
                        { ba: '#.pony', default: 'pony3' }
                    ],
                    waf_rules: '{"rules":[{"rule_id":"1","filters":[{"operator":"@rx","targets":["#.client_ip"],"value":"127.0.0.1"}]}],"flows":[{"name":"flow1","steps":[{"id":"start","rule_ids":["1"],"on_match":"exit_block"}]}]}'
                }
            }
        });

        Shimmer.wrap(require('sq-native').prototype, 'run', (orig) => {

            return function (args) {

                require('sq-native').prototype.run.__unwrap();

                expect(args).to.equal({
                    '#.req[\'headers\'][\'head\']': 'hello'.repeat(10000).slice(0, 4 * 1024),
                    '#.req[\'headers\'][\'head2\']': 'pony2',
                    '#.pony': 'pony3',
                    '#.sess[\'url\'] | url_decode': '<script>',
                    '#.req[\'headers\'][\'head232\'][\'aaa\']': 'pony6'
                });
                return orig.apply(this, arguments);
            };
        });

        const req = {
            url: '%3Cscript%3E',
            headers: {
                'x-forwarded-for': '127.0.0.1',
                head: 'hello'.repeat(10000)
            },
            connection: {
                remoteAddress: '127.0.0.1'
            }
        };

        expect(cb.pre).to.exist();
        const res0 = cb.pre(null, null, null, null, { req }, 100000);
        expect(res0).to.equal({ status: null });

        done();
    });
};

const Os = require('os');
const Semver = require('semver');

const canRun = Semver.satisfies(process.version, '>4')
    && Os.arch() === 'x64'
    && (Os.platform() !== 'win32' || Semver.satisfies(process.version, '>=8'));

if (canRun) {
    describe('PowerWAF', run);
}
