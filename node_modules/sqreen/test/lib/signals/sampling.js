/**
 * Copyright (c) 2016 - 2019 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Sampling = require('../../../lib/signals/sampling');

describe('Signal sampling', () => {

    it('should create an always-true sampler', { plan: 1 }, (done) => {

        const sampler = new Sampling.Sampler([]);
        expect(sampler.shouldCollectAndTick()).to.equal({});
        done();

    });

    it('should refuse to build a sampler', { plan: 1 }, (done) => {

        try  {
            new Sampling.Sampler({});
        }
        catch (e) {
            expect(e).to.exist();
            done();
            return;
        }
        done(new Error('should have thrown'));
    });

    it('should ignore unknown primitives', { plan: 2 }, (done) => {

        const sampler = new Sampling.Sampler([
            { unknown: 1 },
            { calls: 1 }
        ]);

        expect(sampler.shouldCollectAndTick()).to.equal({ calls: 1 });
        const sampler2 = new Sampling.Sampler([
            { unknown: 1 }
        ]);
        expect(sampler2.shouldCollectAndTick()).to.equal(null);

        done();
    });

    it('should create an infinite sampler', { plan: 9 }, (done) => {

        const sampler = new Sampling.Sampler([
            { }
        ]);

        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.shouldCollectAndTick()).to.equal({});
        expect(sampler.ended()).to.be.false();

        done();
    });

    it('should test random sampling', { plan: 2 }, (done) => {

        const sampler = new Sampling.Sampler([
            { random: 0.5 }
        ]);

        const SIZE = 10000;

        let sum = 0;
        for (let i = 0; i < SIZE; ++i) {
            if (sampler.shouldCollectAndTick()) {
                sum += 1;
            }
        }
        const avg = sum / SIZE;
        expect(avg).to.be.above(0.41);
        expect(avg).to.be.below(0.59);
        done();
    });

    it('should create a sampler', { plan: 9 }, (done) => {

        const sampler = new Sampling.Sampler([
            { max_calls: 2, calls: 2 }
        ]);

        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal({ max_calls: 2, calls: 2 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal({ max_calls: 2, calls: 2 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal(null);

        expect(sampler.ended()).to.be.true();
        done();
    });

    it('should create a double sampler', { plan: 9 }, (done) => {

        const sampler = new Sampling.Sampler([
            { max_calls: 2, calls: 2 },
            { max_calls: 3, calls: 2 }
        ]);

        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal({ max_calls: 3, calls: 2 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal({ max_calls: 3, calls: 2 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal({ max_calls: 3, calls: 2 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.shouldCollectAndTick()).to.equal(null);
        expect(sampler.ended()).to.be.true();
        done();
    });

    it('should create a sampler and test stuff', { plan: 6 }, (done) => {

        const sampler = new Sampling.Sampler([
            { max_duration_minutes: 1 / 60 }
        ]);

        expect(sampler.shouldCollectAndTick()).to.equal({ max_duration_minutes: 1 / 60 });
        expect(sampler.shouldCollectAndTick()).to.equal({ max_duration_minutes: 1 / 60 });
        expect(sampler.shouldCollectAndTick()).to.equal({ max_duration_minutes: 1 / 60 });
        expect(sampler.shouldCollectAndTick()).to.equal({ max_duration_minutes: 1 / 60 });
        setTimeout(() => {

            expect(sampler.shouldCollectAndTick()).to.equal({ max_duration_minutes: 1 / 60 });
            setTimeout(() => {

                expect(sampler.shouldCollectAndTick()).to.equal(null);
                done();
            }, 1500);
        }, 100);
    });

    it('should test target per minute', { plan: 12 }, (done) => {

        const sampler = new Sampling.Sampler([
            { target_per_minute: 5 }
        ]);

        // force a flat reference time
        const ontime = Sampling.SamplingLine.timeToFlatMinute(Date.now());
        sampler.lines[0].minuteStart = ontime;
        // fake current time (adding 10s on each call)
        const realDateNow = Date.now.bind(global.Date);
        let count = 0;
        global.Date.now = function () {

            // jump 10s in time
            const now = ontime + count * 10000;
            count++;
            return now;
        };

        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);

        // restore Date.now()
        global.Date.now = realDateNow;

        const sooner = new Date();
        sooner.setMinutes(sooner.getMinutes()  - 1);
        sampler.lines[0].minuteStart = Sampling.SamplingLine.timeToFlatMinute(sooner.getTime());
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal({ target_per_minute: 5 });
        expect(sampler.shouldCollectAndTick()).to.equal(null);

        done();
    });
});
