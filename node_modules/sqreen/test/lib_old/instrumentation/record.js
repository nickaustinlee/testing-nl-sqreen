'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Utils = require('../../testUtils');
const RecordPath = '../../../lib_old/instrumentation/record';

require('../../../lib/command/features').featureHolder.use_signals = false;
const WAF_ATK_EX = {
    'rule_name': 'waf_node_express',
    'test': false,
    'block': false,
    'infos': {
        'waf_data': '[{\"ret_code\":2,\"flow\":\"xss-blocking\",\"step\":\"start\",\"rule\":\"rule_941100\",\"filter\":[{\"operator\":\"@detectXSS\",\"binding_accessor\":\"#.filtered_request_params | flat_values\",\"resolved_value\":\"1256-5465-5555-6666\"}]}]'
    },
    'time': '2019-12-17T17:34:08.716Z',
    'backtrace': [
        'Error: waf_node_express',
        '    at report (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:82:25)',
        '    at performRecordAndObservation (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:155:17)',
        '    at actOnCbResult (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:192:9)',
        '    at sqreenMiddleWare (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:525:35)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:119:46',
        '    at Layer.handle (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/layer.js:95:5)',
        '    at Layer.handle_request (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:170:39)',
        '    at trim_prefix (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:317:13)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:284:7',
        '    at Function.process_params (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:335:12)',
        '    at Function.process_params (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:100:31)',
        '    at next (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:275:10)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/clsAH.js:263:27',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/ns.js:29:27',
        '    at jsonParser (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/body-parser/lib/types/json.js:110:7)',
        '    at Layer.handle (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/layer.js:95:5)'
    ]
};

const WAF_ATK_SAN = {
    'rule_name': 'waf_node_express',
    'test': false,
    'block': false,
    'infos': {
        'waf_data': '[{\"ret_code\":2,\"flow\":\"xss-blocking\",\"step\":\"start\",\"rule\":\"rule_941100\",\"filter\":[{\"operator\":\"@detectXSS\",\"binding_accessor\":\"#.filtered_request_params | flat_values\",\"resolved_value\":\"<Redacted by Sqreen>\"}]}]'
    },
    'time': '2019-12-17T17:34:08.716Z',
    'backtrace': [
        'Error: waf_node_express',
        '    at report (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:82:25)',
        '    at performRecordAndObservation (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:155:17)',
        '    at actOnCbResult (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:192:9)',
        '    at sqreenMiddleWare (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/patch.js:525:35)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:119:46',
        '    at Layer.handle (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/layer.js:95:5)',
        '    at Layer.handle_request (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:170:39)',
        '    at trim_prefix (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:317:13)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:284:7',
        '    at Function.process_params (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:335:12)',
        '    at Function.process_params (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/expressHook.js:100:31)',
        '    at next (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/index.js:275:10)',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/clsAH.js:263:27',
        '    at /Users/vdeturckheim/Projects/express-pg-mongo/node_modules/sqreen/lib/instrumentation/hooks/ns.js:29:27',
        '    at jsonParser (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/body-parser/lib/types/json.js:110:7)',
        '    at Layer.handle (/Users/vdeturckheim/Projects/express-pg-mongo/node_modules/express/lib/router/layer.js:95:5)'
    ]
};


describe('Record old', () => {

    it('should cover the case when instrumentation is disabled', { plan: 0 }, (done) => {

        const Record = require('../../../lib_old/instrumentation/record');
        require('../../../lib/command/features').switchInstrumentationState(false);
        const r = new Record.Record({}, '');
        r.report({}, {});
        require('../../../lib/command/features').switchInstrumentationState(true);
        done();
    });

    it('should write a WAF attack that must be sanitized', { plan: 3 }, (done) => {

        const Config = require('../../../lib/config/index');
        const getConfig = Config.getConfig;
        Config.getConfig = function () {

            return {
                strip_sensitive_data: true,
                strip_sensitive_keys: ['password', 'secret', 'passwd', 'authorization', 'api_key', 'apikey', 'access_token'],
                strip_sentitive_regex: [/^(?:\d[ -]*?){13,16}$/]
            };
        };
        const Record = require('../../../lib_old/instrumentation/record').Record;
        const req = {
            query: {
                cc: '1256-5465-5555-6666'
            }
        };
        const record = new Record(req, '134.23.5.2');
        record.attack(WAF_ATK_EX, '');
        record.mustReport = true;
        expect(record.wafAttack).to.exist();
        record.close(req, 0, {}, {});
        expect(record.wafAttack).to.not.exist();
        expect(record.observed.attacks[0]).to.equal(WAF_ATK_SAN);
        Config.getConfig = getConfig;
        done();
    });

    it('should create a record, fill it and close it', { plan: 10 }, (done) => {

        process.env.SQREEN_TOKEN = 'token';
        require('../../../lib/config/index').getConfig(true);

        const eventStub = {
            writeEvent: function (type, content) {

                expect(type).to.equal('request_record');
                expect(content.req).to.not.exist();
                expect(content.rulespack_id).to.equal('aaa');

                delete process.env.SQREEN_TOKEN;
                done();
            }
        };
        Utils.validateStub(require('../../../lib/events/index'), eventStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);

        const x = {};
        x.x = x;

        const req = {
            __route: '/posts/:id',
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack({
            rule_name: 'ruleName',
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        const err = new Error('myErr');
        record.except({
            klass: Error.name,
            message: err.message,
            infos: {
                client_ip: null,
                args: []
            },
            rule_name: 'ruleName',
            time: new Date(),
            context: {
                backtrace: err.stack.split('\n')
            }
        });

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, null, null, { statusCode: 200, getHeaders: () => ({ 'content-type': 'aaa', 'content-length': 10 }) });
        record.close(req, null, null, { statusCode: 200 });// coverage

        expect(record.request.endpoint).to.equal('/posts/:id');
        expect(record.request.headers).to.be.an.array();
        expect(record.request.headers[0]).to.be.an.array();
        expect(record.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '<Redacted by Sqreen>']);
        expect(record.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: '<Redacted by Sqreen>',
            username: null
        }]);
    });

    it('should create a record, fill it and close it (and collect routing table)', { plan: 10 }, (done) => {

        process.env.SQREEN_TOKEN = 'token';
        require('../../../lib/config/index').getConfig(true);

        const eventStub = {
            writeEvent: function (type, content) {

                expect(type).to.equal('request_record');
                expect(content.req).to.not.exist();
                expect(content.rulespack_id).to.equal('aaa');

                delete process.env.SQREEN_TOKEN;
                done();
            }
        };
        Utils.validateStub(require('../../../lib/events/index'), eventStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);
        Record.TODO.reportExpressTable = true; // TODO: test its reporting somedays

        const x = {};
        x.x = x;

        const req = {
            __route: '/posts/:id',
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack({
            rule_name: 'ruleName',
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        const err = new Error('myErr');
        record.except({
            klass: Error.name,
            message: err.message,
            infos: {
                client_ip: null,
                args: []
            },
            rule_name: 'ruleName',
            time: new Date(),
            context: {
                backtrace: err.stack.split('\n')
            }
        });

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, null, null, { statusCode: 200, getHeaders: () => ({ 'content-type': 'aaa', 'content-length': 10 }) });
        record.close(req, null, null, { statusCode: 200 });// coverage

        expect(record.request.endpoint).to.equal('/posts/:id');
        expect(record.request.headers).to.be.an.array();
        expect(record.request.headers[0]).to.be.an.array();
        expect(record.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '<Redacted by Sqreen>']);
        expect(record.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: '<Redacted by Sqreen>',
            username: null
        }]);
    });

    it('should create a record, fill it and close it without atomization', { plan: 9 }, (done) => {

        delete process.env.SQREEN_TOKEN;
        require('../../../lib/config/index').getConfig(true);

        const eventStub = {
            writeEvent: function (type, content) {

                expect(type).to.equal('request_record');
                expect(content.req).to.not.exist();
                expect(content.rulespack_id).to.equal('aaa');

                delete process.env.SQREEN_TOKEN;
                done();
            }
        };
        Utils.validateStub(require('../../../lib/events/index'), eventStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);

        const x = {};
        x.x = x;

        const req = {
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack({
            rule_name: 'ruleName',
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        const err = new Error('myErr');
        record.except({
            klass: Error.name,
            message: err.message,
            infos: {
                client_ip: null,
                args: []
            },
            rule_name: 'ruleName',
            time: new Date(),
            context: {
                backtrace: err.stack.split('\n')
            }
        });

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, null, null, { statusCode: 200, getHeaders: () => ({ 'content-type': 'aaa', 'content-length': 10 }) });
        record.close(req, null, null, { statusCode: 200 });// coverage

        expect(record.request.headers).to.be.an.array();
        expect(record.request.headers[0]).to.be.an.array();
        expect(record.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '5555-5555-5555-5555']);
        expect(record.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: 'hello',
            username: null
        }]);
    });

    it('should create a record, fill it and close it but not clean stuff', { plan: 9 }, (done) => {

        process.env.SQREEN_STRIP_SENSITIVE_DATA = '0';
        process.env.SQREEN_TOKEN = '0';
        require('../../../lib/config/index').getConfig(true);
        const eventStub = {
            writeEvent: function (type, content) {

                expect(type).to.equal('request_record');
                expect(content.req).to.not.exist();
                expect(content.rulespack_id).to.equal('aaa');

                delete process.env.SQREEN_TOKEN;
                process.env.SQREEN_STRIP_SENSITIVE_DATA = '1';
                done();
            }
        };
        Utils.validateStub(require('../../../lib/events/index'), eventStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);

        const x = {};
        x.x = x;

        const req = {
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack({
            rule_name: 'ruleName',
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        const err = new Error('myErr');
        record.except({
            klass: Error.name,
            message: err.message,
            infos: {
                client_ip: null,
                args: []
            },
            rule_name: 'ruleName',
            time: new Date(),
            context: {
                backtrace: err.stack.split('\n')
            }
        });

        record.observe([['HTTP_CODE', 500, 1]]);

        record.close(req, null, null, { statusCode: 200 });
        record.close(req, null, null, { statusCode: 200 });// coverage

        expect(record.request.headers).to.be.an.array();
        expect(record.request.headers[0]).to.be.an.array();
        expect(record.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '5555-5555-5555-5555']);
        expect(record.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: 'hello',
            username: null
        }]);
    });


    it('should create a record, fill it with only a metric and close it', { plan: 5 }, (done) => {

        const eventStub = {
            writeEvent: function (type, content) {

                done(new Error('should not have been called'));
            }
        };
        const metricStub = {
            addObservations: function (arg) {

                expect(arg).to.be.an.array();
                expect(arg).to.have.length(1);
                expect(arg[0]).to.be.an.array();
                expect(arg[0]).to.have.length(3);
                require('../../../lib/command/features').featureHolder.perf_level = 1;
                done();
            }
        };

        Utils.validateStub(require('../../../lib_old/events'), eventStub);
        Utils.validateStub(require('../../../lib_old/metric'), metricStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub,
            '../metric': metricStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);
        require('../../../lib/command/features').featureHolder.perf_level = 0;

        const req = {
            __sqreen_uuid: 'aa'
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.observe([['HTTP_CODE', 500, 1]], new Date());

        record.close(req);
    });

    it.skip('should have a RR with perf mon', { plan: 3 }, (done) => {

        const Features = require('../../../lib/command/features');
        const Metrics = require('../../../lib_old/metric');
        Metrics.getAllReports(true);
        Features.change({ perf_level: 1, use_signals: false });

        const Record = require(RecordPath);
        Features.switchInstrumentationState(true);
        const requ = {};
        const record = new Record.Record(requ, '127.0.0.1');

        const budget = require('../../../lib/instrumentation/budget').getBudget(Infinity);
        const monitBudget = require('../../../lib/instrumentation/budget').getBudget(Infinity);

        setTimeout(() => {

            record.isClosed = true; // prevent request processing
            record.close(requ, 500, budget, {},  monitBudget);

            const metrics = Metrics.getAllReports(true);

            const req = metrics.find((x) => x.name === 'req');
            const sq = metrics.find((x) => x.name === 'sq');
            const pct = metrics.find((x) => x.name === 'pct');

            expect(req.observation.v.max).to.be.above(900);
            expect(sq.observation.v.max).to.equal(500);
            expect(pct.observation.v.max).to.be.above(.095);

            Features.change({ perf_level: 0 });
            done();
        }, 1000);
    });

    it('should cover the class', { plan: 10 }, (done) => {

        process.env.SQREEN_TOKEN = 'token';
        require('../../../lib/config/index').getConfig(true);

        const eventStub = {
            writeEvent: function (type, content) {

                expect(type).to.equal('request_record');
                expect(content.req).to.not.exist();
                expect(content.rulespack_id).to.equal('aaa');

                delete process.env.SQREEN_TOKEN;
                done();
            }
        };
        Utils.validateStub(require('../../../lib/events/index'), eventStub);

        const Record = Proxyquire(RecordPath, {
            '../events': eventStub
        });
        require('../../../lib/command/features').switchInstrumentationState(true);

        const x = {};
        x.x = x;

        const req = {
            __route: '/posts/:id',
            __sqreen_uuid: 'aa',
            headers: {
                via: 'via-a1',
                'x-forwarded': '5555-5555-5555-5555',
                'x-requested-with': {
                    password: 'hello',
                    username: null
                },
                'x-client-ip': x
            }
        };

        const record = new Record.Record(req, '127.0.0.1');

        expect(Record.STORE.get(req)).to.equal(record);

        record.attack({
            rule_name: 'ruleName',
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        record.attack({
            rule_name: undefined,
            test: true,
            block: false,
            infos: { a: 1 },
            time: new Date(),
            backtrace: (new Error('ruleName')).stack.split('\n')
        }, 'aaa');

        record.identify({});
        record.pushDataPoints([{}]);
        record.addSDK('track', ['', {}]);
        record.addSDK('any', ['', {}]);


        record.close(req, null, null, { statusCode: 200, getHeaders: () => ({ 'Content-Type': 'aaa', 'Content-Length': 10 }) });
        record.close(req, null, null, { statusCode: 200 });// coverage

        expect(record.request.endpoint).to.equal('/posts/:id');
        expect(record.request.headers).to.be.an.array();
        expect(record.request.headers[0]).to.be.an.array();
        expect(record.request.headers.find((w) => w[0] === 'via')).to.equal(['via', 'via-a1']);
        expect(record.request.headers.find((w) => w[0] === 'x-forwarded')).to.equal(['x-forwarded', '<Redacted by Sqreen>']);
        expect(record.request.headers.find((w) => w[0] === 'x-requested-with')).to.equal(['x-requested-with', {
            password: '<Redacted by Sqreen>',
            username: null
        }]);
    });
});
