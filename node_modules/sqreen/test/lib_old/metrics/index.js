/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();
const beforeEach = lab.beforeEach;

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Metric = require('../../../lib_old/metric');

describe('Metric Old', () => {

    beforeEach((done) => {

        Metric._clearAllMetrics();
        require('../../../lib/command/features').featureHolder.use_signals = false;
        done();
    });

    it('should create a new metric and remove it', { plan: 2 }, (done) => {

        new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 61
        });

        expect(Metric._METRIC_STORE.has('login-fail')).to.be.true();
        Metric.removeMetricByName('login-fail');
        expect(Metric._METRIC_STORE.has('login-fail')).to.be.false();
        done();
    });

    it('should create new metrics and remove them by prefix', { plan: 6 }, (done) => {

        const M0 = Object.getPrototypeOf(require('../../../lib_old/metric/collect'));
        new M0({
            kind: 'Sum',
            name: 'sq.1',
            period: 10
        });
        M0.addObservations([['sq.2', 1]], new Date());
        new M0({
            kind: 'Sum',
            name: 'sq2',
            period: 10
        });

        expect(M0._METRIC_STORE.has('sq.1')).to.be.true();
        expect(M0._METRIC_STORE.has('sq.2')).to.be.true();
        expect(M0._METRIC_STORE.has('sq2')).to.be.true();
        M0.removeMetricsByPrefix('sq.');
        expect(M0._METRIC_STORE.has('sq.1')).to.be.false();
        expect(M0._METRIC_STORE.has('sq.2')).to.be.false();
        expect(M0._METRIC_STORE.has('sq2')).to.be.true();
        done();
    });


    it('should accept to create a new metric', { plan: 2 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);
        expect(Metric.getMetric()).to.equal(null);
        done();
    });

    it('should refuse to create a new metric', { plan: 2 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);

        try {
            new Metric({
                kind: 'Sum',
                name: 'login-fail',
                period: 10
            });
        }
        catch (err) {
            expect(err).to.exist();
            done();
        }
    });

    it('should accept to create a new metric and store data', { plan: 3, timeout: 20000 }, (done) => {

        Metric.getAllReports(true);
        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        metric.process();
        metric.currentValue = 1;

        setTimeout(() => {

            metric.process();
            metric.currentValue = 2;
        }, 3000);

        setTimeout(() => {

            expect(metric.values.map((x) => x.observation)).to.equal([1]);
            expect(metric.observe().map((x) => x.observation)).to.equal([1, 2]);
            Metric.getAllReports();
            expect(metric.values).to.equal([]);
            done();
        }, 6000);
    });

    it('should accept to create a new metric, store data and get reportable data', { plan: 5, timeout: 20000 }, (done) => {

        Metric.addObservations([]);
        Metric.getAllReports(true);
        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        metric.process();
        metric.currentValue = { id: 1 };

        setTimeout(() => {

            metric.process();
            metric.currentValue = { id: 2 };
        }, 3000);

        setTimeout(() => {

            metric.process();
            expect(metric.values.map((x) => x.observation)).to.equal([{ id: 1 }, { id: 2 }]);

            const report = metric.report;
            expect(report[0].observation).to.equal({ id: 1 });
            if ((report[0].finish - report[0].start) % 1000 < 3) {
                expect(Math.abs(3000 - (report[1].finish - report[1].start))).to.be.below(16.5);
            }
            else {
                expect(Math.abs(3000 - (report[0].finish - report[0].start))).to.be.below(1000 + 16.5);
            }
            expect(report[1].observation).to.equal({ id: 2 });
            Metric.getAllReports();
            expect(metric.values).to.equal([]);
            done();
        }, 6000);
    });

    it('should accept to create a new metric, store data and get reportable data through getAllReports', { plan: 8, timeout: 20000 }, (done) => {

        Metric.getAllReports(true);
        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        const metric2 = new Metric({
            kind: 'Sum',
            name: 'login-success',
            period: 2
        });

        metric.process();
        metric.currentValue = { id: 1 };
        metric2.currentValue = { id: 1 };

        setTimeout(() => {

            metric.process();
            metric.currentValue = { id: 2 };
        }, 3000);

        setTimeout(() => {

            metric.process();
            expect(metric.values.map((x) => x.observation)).to.equal([{ id: 1 }, { id: 2 }]);

            const reports = Metric.getAllReports(true);
            expect(reports).to.have.length(3);
            expect(reports[0].name).to.equal('login-fail');
            expect(reports[0].observation).to.equal({ id: 1 });

            expect(reports[1].name).to.equal('login-fail');
            expect(reports[1].observation).to.equal({ id: 2 });

            expect(reports[2].name).to.equal('login-success');
            expect(reports[2].observation).to.equal({ id: 1 });

            done();
        }, 6000);
    });

    describe('addObservations', () => {

        it('should create a new metric and add observations to it', { plan: 3, timeout: 5000 }, (done) => {

            const rule = {
                name: 'rule',
                metrics: [
                    {
                        kind: 'Sum',
                        name: 'test',
                        period: 2
                    },
                    {
                        kind: 'none',
                        name: 'none',
                        period: 15
                    }
                ]
            };

            rule.metrics.forEach(Metric.getMetric);

            const observations = [['test', 'unicorn', 1], ['test', 'pony', 2], ['none', 'nono', 10]];

            Metric.addObservations(observations);
            Metric.addObservations([['test', 'unicorn', 1]]);
            const noneMetric = Metric.getMetricByName(Metric.getName(rule.metrics[1]));
            const metric = Metric.getMetricByName(Metric.getName(rule.metrics[0]));

            expect(noneMetric).to.not.exist();
            expect(metric).to.exist();
            setTimeout(() => {

                const result = metric.observe();
                expect(result.map((r) => r.observation)).to.equal([{ 'unicorn': 2, 'pony': 2 }]);
                done();
            }, 3000);

        });
    });

});
