/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Util = require('../lib/util');
const Proxyquire = require('proxyquire');

describe('utils', () => {

    describe('parseStackTraceLine', () => {

        it('should cover parseStackTraceLine', { plan: 2 }, (done) => {

            expect(Util.parseStackTraceLine(' at /Users/vdeturckheim/AgentNode/test/lib/exception/index.js:25:21')).to.exist();
            expect(Util.parseStackTraceLine( ' at Script.runInThisContext (vm.js:128:20)')).to.exist();
            done();
        });
    });

    describe('timeout', () => {

        it('should return a promise resolved after a while', { plan: 2 }, () => {

            const t0 = new Date();

            return Util.timeout(500)
                .then(() => {

                    const t1 = new Date();
                    expect(t1 - t0).to.be.above(450);
                    expect(t1 - t0).to.be.below(550);
                });
        });
    });

    describe('createPathInObject', () => {

        it('should create a path in the object', { plan: 8 }, (done) => {

            const obj = { a: { x: 1, b: { y: 2 } } };

            Util.createPathInObject(obj, ['a', 'b', 'c']);

            expect(obj).to.exist();
            expect(obj.a).to.exist();
            expect(obj.a.b).to.exist();
            expect(obj.a.b.c).to.exist();
            expect(obj.a.b.c).to.equal({});
            expect(obj.a.b).to.equal({ c: {}, y: 2 });
            expect(obj.a).to.equal({ b: { c: {}, y: 2 }, x: 1 });
            expect(obj).to.equal({ a: { b: { c: {}, y: 2 }, x: 1 } });
            done();

        });
    });

    describe('getClientIpFromRequest', () => {

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest()).to.not.exist();
            done();
        });

        it('should return x-forwarded-for', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest({ headers: { 'x-real-ip': 'aa', 'x-forwarded-for': 'bb' } })).to.equal('aa');
            done();
        });

        it('should return bb', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest({ headers: { 'x-forwarded-for': 'bb, cc' }, connection: {} })).to.equal('cc');
            done();
        });

        it('should return bb', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest({ headers: { 'x-forwarded-for': 'bb' }, connection: { remoteAddress: 'oo' } })).to.equal('bb');
            done();
        });

        it('should return oo', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest({ headers: { }, connection: { remoteAddress: 'oo' } })).to.equal('oo');
            done();
        });

        it('should return oo', { plan: 1 }, (done) => {

            expect(Util.getClientIpFromRequest({ connection: { remoteAddress: 'oo' } })).to.equal('oo');
            done();
        });
    });

    describe('getXFFOrRemoteAddress', () => {

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ connection: { remoteAddress: ':' } })).to.equal(':');
            done();
        });

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ connection: { remoteAddress: 40 } })).to.equal('');
            done();
        });

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': {} }, connection: { remoteAddress: ':' } })).to.equal(':');
            done();
        });

        it('should return something', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': 'xx, yy, 127.0.0.1, 192.168.0.1, 8.8.8.8' }, connection: { remoteAddress: ':' } })).to.equal('8.8.8.8');
            done();
        });

        it('should return something', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': 'xx, ::1, 127.0.0.1, 192.168.0.1, 8.8.8.8' }, connection: { remoteAddress: ':' } })).to.equal('8.8.8.8');
            done();
        });

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { remoteAddress: ':' } })).to.equal(':');
            done();
        });

        it('should return nothing', { plan: 1 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { remoteAddress: 'dflasjdfs' }, ip: '127.0.0.1' })).to.equal('127.0.0.1');
            done();
        });
        it('should return nothing', { plan: 2 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: {  }, connection: { remoteAddress: 'dflasjdfs' }, ip: '127.0.0.1' })).to.equal('127.0.0.1');
            expect(Util.getXFFOrRemoteAddress({ headers: {  }, connection: { remoteAddress: '192.168.0.1' }, ip: '127.0.0.1' })).to.equal('192.168.0.1');
            done();
        });

        it('should return bestCandidate', { plan: 3 }, (done) => {

            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { remoteAddress: '127.0.0.1' } })).to.equal('192.168.0.1');
            expect(Util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { } })).to.equal('192.168.0.1');
            expect(Util.getXFFOrRemoteAddress({ headers: { }, connection: { } })).to.equal('');
            done();
        });

        it('should return ip based on config', { plan: 2 }, (done) => {

            const util = Proxyquire('../lib/util', {
                './config/index': {
                    getConfig: () => ({ ip_header: 'my-header' })
                }
            });

            expect(util.getXFFOrRemoteAddress({ headers: { 'my-header': '8.8.8.8', 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { remoteAddress: '127.0.0.1' } })).to.equal('8.8.8.8');
            expect(util.getXFFOrRemoteAddress({ headers: { 'x-forwarded-for': '127.0.0.1, 192.168.0.1' }, connection: { remoteAddress: '127.0.0.1' } })).to.equal('192.168.0.1');
            done();
        });
    });

    describe('Queue', () => {

        it('should queue stuff and flush', { plan: 12 }, (done) => {

            new Util.Queue();
            const queue = new Util.Queue(5);

            for (let i = 0; i <  10; ++i) {
                queue.push('hello' + i);
                expect(queue.length).to.equal(Math.min(i + 1, 5));
            }

            const fl = queue.flush();
            expect(queue.length).to.equal(0);
            expect(fl).to.equal(['hello5', 'hello6', 'hello7', 'hello8', 'hello9']);

            done();
        });
    });

    describe('ensureProperIP', () => {

        it('should test the method', { plan: 7 }, (done) => {

            expect(Util.ensureProperIP('126.33.45.55')).to.equal('126.33.45.55');
            expect(Util.ensureProperIP('126.33.45.55:9999')).to.equal('126.33.45.55');
            expect(Util.ensureProperIP('126.33.::45.55:9999')).to.equal('');
            expect(Util.ensureProperIP('')).to.equal('');
            expect(Util.ensureProperIP(null)).to.equal('');
            expect(Util.ensureProperIP('::1.')).to.equal('');
            expect(Util.ensureProperIP(':.')).to.equal('');
            done();
        });
    });

    describe('isEmitter', () => {

        it('should cover isEmitter', { plan: 4 }, (done) => {

            expect(Util.isEmitter({})).to.be.false();
            expect(Util.isEmitter({ on: true })).to.be.false();
            expect(Util.isEmitter({ on: true, addListener: true })).to.be.false();
            expect(Util.isEmitter({ on: true, addListener: true, emit: true })).to.be.true();
            done();
        });
    });
});
